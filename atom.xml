<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的日常生活分享</title>
  
  
  <link href="https://hustchenshu.github.io/atom.xml" rel="self"/>
  
  <link href="https://hustchenshu.github.io/"/>
  <updated>2022-08-24T02:19:18.059Z</updated>
  <id>https://hustchenshu.github.io/</id>
  
  <author>
    <name>hustchenshu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://hustchenshu.github.io/2022/08/24/ali/"/>
    <id>https://hustchenshu.github.io/2022/08/24/ali/</id>
    <published>2022-08-24T02:19:18.059Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<p>/*<br>    提示，5道时间1个小时，可以使用伪代码方式<br>*/</p><p>/*<br> 问题1：在移动开发中会有触发比较频繁的事件，比如抢购时用户快速点击一个按钮，会导致频繁调用 API。请完成下面函数 throttle<br> */</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">func</span></span> - The function to throttle.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">delay</span></span> - The number of milliseconds to throttle invocations to.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span> </span>Returns the new throttled function.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">        valid = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>/*<br> 问题2：列举至少5种常规排序算法，请编写快速排序排序算法。<br>*/<br>1、冒泡；2、sort 排序；3、选择排序；4、插入排序；5、快速排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">arr, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stand = arr[start];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; arr[end] &gt; stand) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[start] = arr[end]; </span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; arr[start] &lt;= stand) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end] = arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = stand;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end = arr.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> index = partition(arr, start, end);</span><br><span class="line">    quickSort(arr, start , index - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<br> 问题3：树的深度优先搜索（DFS）广度优先搜索（BFS）<br>*/<br>// 深度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; left, right, val &#125; = root;</span><br><span class="line">    exec(val); <span class="comment">// do something</span></span><br><span class="line">    dfs(left);</span><br><span class="line">    dfs(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 广度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> len = stack.length;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> cur = stack.shift();</span><br><span class="line">            <span class="keyword">const</span> &#123; left, right, val &#125; = cur;</span><br><span class="line">            exec(val); <span class="comment">// do something</span></span><br><span class="line">            left &amp;&amp; stack.push(left);</span><br><span class="line">            right &amp;&amp; stack.push(right);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<br> 问题4：// 实现一个Promise.all 函数。  假设Promise其他API都存在，仅仅实现Promise.all . 不能使用await async<br>*/</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!promises[<span class="built_in">Symbol</span>.iterator]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;arg is not iterable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> results = [];</span><br><span class="line">        <span class="keyword">const</span> len = promises.length;</span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            resolve(results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> succCount = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> curItem <span class="keyword">of</span> promises) &#123;</span><br><span class="line">            <span class="keyword">let</span> resultIndex = index++;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(curItem).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                results[resultIndex] = value;</span><br><span class="line">                succCount++;</span><br><span class="line">                <span class="keyword">if</span>(succCount === len) &#123;</span><br><span class="line">                    resolve(results);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise.all([1,2,3]).then((res) =&gt; &#123;</span></span><br><span class="line"><span class="comment">// console.log(val, val2)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 问题5：二维数组螺旋输出，如输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var arr =</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// [4, 5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8, 9]</span></span><br><span class="line"><span class="comment">// 则输出：</span></span><br><span class="line"><span class="comment">// 1，4，2，7，5，3，8，6，9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> row = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(!row) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> column = arr[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 从上往下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j].length) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(arr[j].shift());</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左往右</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; column; m++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">0</span> &amp;&amp; arr[n].length) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(arr[n].shift());</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(&#123;arr&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr =[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;/*&lt;br&gt;    提示，5道时间1个小时，可以使用伪代码方式&lt;br&gt;*/&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt; 问题1：在移动开发中会有触发比较频繁的事件，比如抢购时用户快速点击一个按钮，会导致频繁调用 API。请完成下面函数 throttle&lt;br&gt; */&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hustchenshu.github.io/2022/08/24/vue%20%E9%9D%A2%E8%AF%95/"/>
    <id>https://hustchenshu.github.io/2022/08/24/vue%20%E9%9D%A2%E8%AF%95/</id>
    <published>2022-08-24T02:19:18.059Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#1-mvc-%E5%92%8C-mvvm-%E5%8C%BA%E5%88%AB">1. 、MVC 和 MVVM 区别</a></li><li><a href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88data%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">2. 、为什么data是一个函数</a></li><li><a href="#3-vue%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">3. 、Vue组件通讯有哪些方式？</a></li><li><a href="#4-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%80%E8%88%AC%E5%9C%A8%E5%93%AA%E4%B8%80%E6%AD%A5%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">4. 、Vue的生命周期方法有哪些？一般在哪一步发送请求？</a></li><li><a href="#5-v-if-%E5%92%8C-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB">5. 、v-if 和 v-show 的区别</a></li><li><a href="#6-%E8%AF%B4%E8%AF%B4-vue-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4">6. 、说说 vue 内置指令</a></li><li><a href="#7-%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE%E6%B5%81">7. 、怎样理解 Vue 的单项数据流</a></li><li><a href="#8-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF">8. 、computed 和 watch 的区别和运用的场景。</a></li><li><a href="#9-v-if-%E5%92%8C-v-for-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">9. 、v-if 和 v-for 为什么不建议一起使用</a></li><li><a href="#10-vue-20-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86">10. 、Vue 2.0 响应式数据的原理</a></li><li><a href="#11-vue-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96">11. 、Vue 如何检测数组变化</a></li><li><a href="#12-vue30-%E7%94%A8%E8%BF%87%E5%90%97%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B">12. 、Vue3.0 用过吗？了解多少？有哪些改进？</a></li><li><a href="#13-vue30-%E5%92%8C-20-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB">13. 、Vue3.0 和 2.0 的响应式原理区别</a></li><li><a href="#14-vue%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">14. 、Vue的父子组件生命周期钩子函数执行顺序</a></li><li><a href="#15-%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9">15. 、虚拟DOM是什么？有什么优缺点？</a></li><li><a href="#16-v-model-%E5%8E%9F%E7%90%86">16. 、v-model 原理</a></li><li><a href="#17-v-for%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0key">17. 、v-for为什么要加key</a></li><li><a href="#18-vue%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">18. 、Vue事件绑定原理</a></li><li><a href="#19-vue-router-%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88">19. 、vue-router 路由钩子函数是什么？执行顺序是什么？</a></li><li><a href="#20-vue-router-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">20. 、vue-router 动态路由是什么？有什么问题。</a></li><li><a href="#21-%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9-vuex-%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3">21. 、谈一下对 vuex 的个人理解</a></li><li><a href="#22-vuex-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">22. 、Vuex 页面刷新数据丢失怎么解决？</a></li><li><a href="#23-vuex-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E6%A8%A1%E5%9D%97%E5%B9%B6%E4%B8%94%E5%8A%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">23. 、Vuex 为什么要分模块并且加命名空间？</a></li><li><a href="#24-%E4%BD%BF%E7%94%A8%E8%BF%87-vue-ssr-%E5%90%97%E8%AF%B4%E8%AF%B4-ssr">24. 、使用过 Vue SSR 吗？说说 SSR</a></li><li><a href="#25-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">25. 、vue 中使用了哪些设计模式？</a></li><li><a href="#26-%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">26. 、你都做过哪些 Vue 的性能优化？</a></li><li><a href="#27-vuemixin-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86">27. 、Vue.mixin 的使用场景和原理</a></li><li><a href="#28-nexttick-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86">28. 、nextTick 使用场景和原理</a></li><li><a href="#29-keep-alive-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86">29. 、keep-alive 使用场景和原理</a></li><li><a href="#30-vueset-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86">30. 、Vue.set 方法原理</a></li><li><a href="#31-vueextend-%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86">31. 、Vue.extend 作用和原理</a></li><li><a href="#32-%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%90%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">32. 、写过自定义指令吗？原理是什么？</a></li><li><a href="#33-vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B">33. 、Vue 修饰符有哪些？</a></li><li><a href="#34-vue-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">34. 、Vue 模板编译原理</a></li><li><a href="#35-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">35. 、生命周期钩子是如何实现的</a></li><li><a href="#36-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86">36. 、函数式组件使用场景和原理</a></li><li><a href="#37-%E8%83%BD%E8%AF%B4%E4%B8%8B-vue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97">37. 、能说下 vue-router 中常用的路由模式和实现原理吗？</a></li><li><a href="#38-diff-%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97">38. 、diff 算法了解吗？</a></li><li><a href="#39-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">39. 双向绑定</a></li><li><a href="#40-proxy-%E7%9B%B8%E6%AF%94%E4%BA%8E-defineproperty-%E7%9A%84%E4%BC%98%E5%8A%BF">40. 、Proxy 相比于 defineProperty 的优势</a></li><li><a href="#41-vue%E4%B8%8Ereact%E7%9A%84%E5%8C%BA%E5%88%AB">41. 、Vue与React的区别</a></li></ul><!-- /TOC --><h1 id="1-、MVC-和-MVVM-区别"><a href="#1-、MVC-和-MVVM-区别" class="headerlink" title="1. 、MVC 和 MVVM 区别"></a>1. 、MVC 和 MVVM 区别</h1><p>MVC<br>MVC全名是 Model View Controller,时模型 - 视图 - 控制器的缩写，一种软件设计典范。</p><p>Model(模型)：是用于处理应用程序数据逻辑部分。通常模型对象负责在数据库中存取数据。<br>View(视图)：是应用程序中处理数据显示的本分。通常视图是依据模型数据创建的。<br>Controller(控制器)：是应用程序处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><p>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。<br>MVVM<br>MVVM新增了VM类。</p><p>ViewModel层：做了两件事达到了数据的双向绑定，一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。 实现的方式时：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转换成后端的数据。实现的方式是：DOM事件监听。</p><p>MVVM与MVC最大的区别就是：实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再手动操作Dom元素来改变View的显示。 而是改变属性后该属性对应的View层显示会自动改变（对应Vue数据驱动的思想）<br>整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也察觉不到View，这种低耦合模式提高代码的可重用性。<br>注意：Vue并没有完全遵循MVVM的思想，这一点官网自己也有声明。</p><p>那么问题来了，为什么官方要说Vue没有完全遵循MVVM思想呢？<br>严格的MVVVM要求View不能和Model直接通信，而Vue提供了$refs这个属性，让Model可以直接操作View，违反了这一规定，所以是Vue没有完全遵循MVVM。</p><h1 id="2-、为什么data是一个函数"><a href="#2-、为什么data是一个函数" class="headerlink" title="2. 、为什么data是一个函数"></a>2. 、为什么data是一个函数</h1><p>组件的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一分新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p><h1 id="3-、Vue组件通讯有哪些方式？"><a href="#3-、Vue组件通讯有哪些方式？" class="headerlink" title="3. 、Vue组件通讯有哪些方式？"></a>3. 、Vue组件通讯有哪些方式？</h1><ul><li><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p></li><li><p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p></li><li><p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p></li><li><p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p></li><li><p>5、$refs 获取组件实例。</p></li><li><p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p></li><li><p>7、vuex 状态管理。</p></li></ul><h1 id="4-、Vue的生命周期方法有哪些？一般在哪一步发送请求？"><a href="#4-、Vue的生命周期方法有哪些？一般在哪一步发送请求？" class="headerlink" title="4. 、Vue的生命周期方法有哪些？一般在哪一步发送请求？"></a>4. 、Vue的生命周期方法有哪些？一般在哪一步发送请求？</h1><ul><li>beforeCreate </li></ul><p>在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p><ul><li>created</li></ul><p>实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。</p><ul><li>beforeMount</li></ul><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p><ul><li>mounted</li></ul><p>在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。</p><ul><li>beforeUpdate </li></ul><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p><ul><li>updated </li></ul><p>发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。</p><ul><li>beforeDestroy</li></ul><p>实例销毁之前调用。在这一步，实力仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。</p><ul><li>destroy </li></ul><p>Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。</p><ul><li>activated </li></ul><p>keep-alive 专属，组件被激活时调用</p><ul><li>deactivated </li></ul><p>keep-alive 专属，组件被销毁时调用</p><p>异步请求在哪一步发起？<br>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务器端返回的数据进行赋值。</p><p>如果异步请求不需要依赖 DOM 推荐加载 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><p>能更快获取到服务端数据，减少页面loading时间；<br>ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。</p><h1 id="5-、v-if-和-v-show-的区别"><a href="#5-、v-if-和-v-show-的区别" class="headerlink" title="5. 、v-if 和 v-show 的区别"></a>5. 、v-if 和 v-show 的区别</h1><p>v-if 在编译过程中会被转化成三元表达式，条件不满足时不渲染此节点。</p><p>v-show 会被编译成指令，条件不满足时控制样式将此节点隐藏（display:none）</p><p>使用场景<br>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景。</p><p>v-show 适用于需要非常频繁切换条件的场景。</p><p>扩展补充：display:none 、 visibility:hidden 和 opacity:0 之间的区别？</p><p>三者公共点都是隐藏。不同点：</p><ul><li>一、是否占据空间。<br>display:none，隐藏之后不占位置；visibility:hidden、opacity:0，隐藏后任然占据位置。</li><li>二、子元素是否继承。<br>display:none — 不会被子元素继承，父元素都不存在了，子元素也不会显示出来。<br>visibility:hidden — 会被子元素继承，通过设置子元素 visibility:visible 来显示子元素。<br>opacity:0 — 会被子元素继承，但是不能设置子元素 opacity:0 来先重新显示。</li><li>三、事件绑定。<br>display:none 的元素都已经不存在了，因此无法触发他绑定的事件。<br>visibility:hidden 不会触发他上面绑定的事件。<br>opacity:0 元素上面绑定的事件时可以触发的。</li><li>四、过度动画。<br>transition对于display是无效的。<br>transition对于visibility是无效的。<br>transition对于opacity是有效的。</li></ul><h1 id="6-、说说-vue-内置指令"><a href="#6-、说说-vue-内置指令" class="headerlink" title="6. 、说说 vue 内置指令"></a>6. 、说说 vue 内置指令</h1><ul><li>v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。</li><li>v-cloak - 这个指令保持在元素上直到关联实例结束编译 – 解决初始化慢到页面闪动的最佳实践。</li><li>v-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。</li><li>v-on - 用于监听DOM事件。例如 v-on:click v-on:keyup</li><li>v-html - 赋值就是变量的innerHTML – 注意防止xss攻击</li><li>v-text - 更新元素的textContent</li><li>v-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。</li><li>v-if / v-else / v-else-if。可以配合template使用；在render函数里面就是三元表达式。</li><li>v-show - 使用指令来实现 – 最终会通过display来进行显示隐藏</li><li>v-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，不要使用index作为key。</li><li>v-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度。</li></ul><h1 id="7-、怎样理解-Vue-的单项数据流"><a href="#7-、怎样理解-Vue-的单项数据流" class="headerlink" title="7. 、怎样理解 Vue 的单项数据流"></a>7. 、怎样理解 Vue 的单项数据流</h1><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。</p><p>注意：在子组件直接用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。</p><p>如果实在要改变父组件的 props 值可以再data里面定义一个变量，并用 prop 的值初始化它，之后用$emit 通知父组件去修改。</p><h1 id="8-、computed-和-watch-的区别和运用的场景。"><a href="#8-、computed-和-watch-的区别和运用的场景。" class="headerlink" title="8. 、computed 和 watch 的区别和运用的场景。"></a>8. 、computed 和 watch 的区别和运用的场景。</h1><p>computed 是计算属性，依赖其它属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，他可以设置getter和setter。</p><p>watch 监听到值的变化就会执行回调，在回调中可以进行一系列的操作。</p><p>计算属性一般用在模板渲染中，某个值是依赖其它响应对象甚至是计算属性而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p><h1 id="9-、v-if-和-v-for-为什么不建议一起使用"><a href="#9-、v-if-和-v-for-为什么不建议一起使用" class="headerlink" title="9. 、v-if 和 v-for 为什么不建议一起使用"></a>9. 、v-if 和 v-for 为什么不建议一起使用</h1><p>v-for和v-if不要在同一标签中使用，因为解析时先解析v-for在解析v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式。</p><h1 id="10-、Vue-2-0-响应式数据的原理"><a href="#10-、Vue-2-0-响应式数据的原理" class="headerlink" title="10. 、Vue 2.0 响应式数据的原理"></a>10. 、Vue 2.0 响应式数据的原理</h1><p>整体思路是数据劫持 + 观察者模式</p><p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存在它所依赖的 watcher （依赖收集）get，当属性变化后会通知自己对应的 watcher 去更新（派发更新）set。</p><ul><li>1、Object.defineProperty 数据劫持</li><li>2、使用 getter 收集依赖 ，setter 通知 watcher派发更新。</li><li>3、watcher 发布订阅模式。</li></ul><h1 id="11-、Vue-如何检测数组变化"><a href="#11-、Vue-如何检测数组变化" class="headerlink" title="11. 、Vue 如何检测数组变化"></a>11. 、Vue 如何检测数组变化</h1><p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对7种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写（AOP 切片思想）。</p><p>所以在 Vue 中修改数组的索引和长度无法监控到。需要通过以上7种变异方法修改数组才会触发数组对应的watcher进行更新。</p><h1 id="12-、Vue3-0-用过吗？了解多少？有哪些改进？"><a href="#12-、Vue3-0-用过吗？了解多少？有哪些改进？" class="headerlink" title="12. 、Vue3.0 用过吗？了解多少？有哪些改进？"></a>12. 、Vue3.0 用过吗？了解多少？有哪些改进？</h1><ul><li><p>响应式原理的改变</p><p>Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty。</p></li><li><p>组件选项声明方式</p><p> Vue3.x 使用 Composition API setup是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口。</p></li><li><p>重写虚拟dom</p><p>编译时添加PatchFlag来标识动/静态节点，diff时直接跳过静态节点，更多的编译时提示来减少运行时开销，</p></li><li><p>模板语法变化</p></li><li><p>slot 具名插槽语法</p></li><li><p>自定义指令v-model升级。</p></li></ul><p>其他方面的更改 Suspense支持Fragment（多个根节点）和 Protal（在dom其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。基于 treeShaking 优化，提供了更多的内置功能。</p><h1 id="13-、Vue3-0-和-2-0-的响应式原理区别"><a href="#13-、Vue3-0-和-2-0-的响应式原理区别" class="headerlink" title="13. 、Vue3.0 和 2.0 的响应式原理区别"></a>13. 、Vue3.0 和 2.0 的响应式原理区别</h1><p>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达13种拦截方法。</p><h1 id="14-、Vue的父子组件生命周期钩子函数执行顺序"><a href="#14-、Vue的父子组件生命周期钩子函数执行顺序" class="headerlink" title="14. 、Vue的父子组件生命周期钩子函数执行顺序"></a>14. 、Vue的父子组件生命周期钩子函数执行顺序</h1><ul><li><p>加载渲染过程</p><p>  父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p></li><li><p>子组件更新过程</p><p>  父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p></li><li><p>父组件更新过程</p><p>  父beforeUpdate -&gt; 父updated</p></li><li><p>销毁过程</p><p>  父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroye</p></li></ul><h1 id="15-、虚拟DOM是什么？有什么优缺点？"><a href="#15-、虚拟DOM是什么？有什么优缺点？" class="headerlink" title="15. 、虚拟DOM是什么？有什么优缺点？"></a>15. 、虚拟DOM是什么？有什么优缺点？</h1><p>由于在浏览器中操作DOM是很昂贵的。频繁操作DOM，会产生一定性能问题。这就是虚拟Dom的产生原因。Vue2的Virtual DOM 借鉴了开源库 snabbdom 的实现。Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点，是对真实DOM的一层抽象。</p><p><code>优点</code>：</p><ul><li>1、保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限。</li><li>2、无需手动操作DOM：我们不需手动去操作DOM，只需要写好 View-Model的 代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。</li><li>3、跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器端渲染、weex开发等等。</li></ul><p><code>缺点</code>：</p><ul><li>1、无法进行极致优化：虽然虚拟DOM + 合理的优化，足以应对大部分应用的性能需要，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。</li><li>2、首次渲染大量DOM时，由于多了一层DOM计算，会比innerHTML插入慢。</li></ul><h1 id="16-、v-model-原理"><a href="#16-、v-model-原理" class="headerlink" title="16. 、v-model 原理"></a>16. 、v-model 原理</h1><p>v-model 只是语法糖而已。<br>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。<br>注意：对于需要使用输入法的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。<br>在普通元素上：<br>input v-model=’sth’<br>input v-bind:value=’sth’ v-on:input=’sth = $event.target.value’</p><h1 id="17-、v-for为什么要加key"><a href="#17-、v-for为什么要加key" class="headerlink" title="17. 、v-for为什么要加key"></a>17. 、v-for为什么要加key</h1><p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速。<br>更准确：因为带key就不是就地复用了，在sameNode函数 a.key === b.key 对比中可以避免就地复用的情况。所以更加准确。<br>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式块。</p><h1 id="18-、Vue事件绑定原理"><a href="#18-、Vue事件绑定原理" class="headerlink" title="18. 、Vue事件绑定原理"></a>18. 、Vue事件绑定原理</h1><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。如果要在组件上使用原生事件，需要加.native修饰符，这样就相当于在父组件中把子组件当做普通的HTML标签，然后加上原生事件。<br>$on、$emit 是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里的对应的监听器。</p><h1 id="19-、vue-router-路由钩子函数是什么？执行顺序是什么？"><a href="#19-、vue-router-路由钩子函数是什么？执行顺序是什么？" class="headerlink" title="19. 、vue-router 路由钩子函数是什么？执行顺序是什么？"></a>19. 、vue-router 路由钩子函数是什么？执行顺序是什么？</h1><p>路由钩子的执行流程，钩子函数种类有：全局守卫、路由守卫、组件守卫。<br>完整的导航解析流程：</p><ul><li>1、导航被触发。</li><li>2、在失活的组件里调用 beforeRouterLeave 守卫。</li><li>3、调用全局的 beforeEach 守卫。</li><li>4、在重用的组件调用 beforeRouterUpdate 守卫（2.2+）。</li><li>5、在路由配置里面 beforeEnter。</li><li>6、解析异步路由组件。</li><li>7、在被激活的组件里调用 beforeRouterEnter。</li><li>8、调用全局的 beforeResolve 守卫（2.5+）。</li><li>9、导航被确认。</li><li>10、调用全局的 afterEach 钩子。</li><li>11、触发 DOM 更新。</li><li>12、调用 beforeRouterEnter 守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ul><h1 id="20-、vue-router-动态路由是什么？有什么问题。"><a href="#20-、vue-router-动态路由是什么？有什么问题。" class="headerlink" title="20. 、vue-router 动态路由是什么？有什么问题。"></a>20. 、vue-router 动态路由是什么？有什么问题。</h1><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”（dynamic segment）来达到这个效果： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123; <span class="attr">template</span>: <span class="string">&quot;User&quot;</span>, &#125;;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>, </span><br><span class="line">            <span class="attr">component</span>: User</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>问题：vue-router 组件复用导致路由参数失效怎么办？<br>解决方案：<br>1、通过watch监听路由参数再发请求<br>watch：{<br>“router”:function(){<br>this.getData(this.$router.params.xxx)<br>}<br>}<br>2、用 :key来阻止复用<br>router-view :key=”$route.fullPath”</p><h1 id="21-、谈一下对-vuex-的个人理解"><a href="#21-、谈一下对-vuex-的个人理解" class="headerlink" title="21. 、谈一下对 vuex 的个人理解"></a>21. 、谈一下对 vuex 的个人理解</h1><p>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部内心原理是通过创造一个全局实例 new Vue）</p><p>主要包括以下几个模块：</p><ul><li>State:定义了应用状态的数据结构，可以在这里设置默认的初始化状态。</li><li>Getter:允许组件从Store中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation:是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action:用于提交 mutation，而不是直接变更状态，可以包含任意异步请求。</li><li>Module:允许将单一的 Store 拆分更多个 store 且同时保存在单一的状态树中。</li></ul><h1 id="22-、Vuex-页面刷新数据丢失怎么解决？"><a href="#22-、Vuex-页面刷新数据丢失怎么解决？" class="headerlink" title="22. 、Vuex 页面刷新数据丢失怎么解决？"></a>22. 、Vuex 页面刷新数据丢失怎么解决？</h1><p>需要做 vuex 数据持久化，一般使用本地储存的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件。<br>推荐使用 vuex-persist (脯肉赛斯特)插件，它是为 Vuex 持久化储存而生的一个插件。不需要你手动存取 storage，而是直接将状态保存至 cookie 或者 localStorage中。</p><h1 id="23-、Vuex-为什么要分模块并且加命名空间？"><a href="#23-、Vuex-为什么要分模块并且加命名空间？" class="headerlink" title="23. 、Vuex 为什么要分模块并且加命名空间？"></a>23. 、Vuex 为什么要分模块并且加命名空间？</h1><p>模块： 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能会变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p><p>命名空间： 默认情况下，模块内部的 action、mutation、getter是注册在全局命名空间的 — 这样使得多个模块能够对同一 mutation 或 action 做出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced:true 的方式使其成为带命名的模块。当模块被注册后，他所有 getter、action、及 mutation 都会自动根据模块注册的路径调整命名。</p><h1 id="24-、使用过-Vue-SSR-吗？说说-SSR"><a href="#24-、使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="24. 、使用过 Vue SSR 吗？说说 SSR"></a>24. 、使用过 Vue SSR 吗？说说 SSR</h1><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p><code>优点：</code><br>SSR 有着更好的 SEO、并且首屏加载速度更快。<br><code>缺点：</code><br>开发条件会受限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。<br>服务器会有更大的负载需求。</p><h1 id="25-、vue-中使用了哪些设计模式？"><a href="#25-、vue-中使用了哪些设计模式？" class="headerlink" title="25. 、vue 中使用了哪些设计模式？"></a>25. 、vue 中使用了哪些设计模式？</h1><ul><li><p>1、工厂模式 - 传入参数即可创建实例<br>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode。</p></li><li><p>2、单例模式 - 整个程序有且仅有一个实例<br>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉。</p></li><li><p>3、发布-订阅模式。（vue 事件机制）</p></li><li><p>4、观察者模式。（响应式数据原理）</p></li><li><p>5、装饰器模式（@装饰器的用法）</p></li><li><p>6、策略模式，策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现方案 - 比如选项的合并策略。</p></li></ul><h1 id="26-、你都做过哪些-Vue-的性能优化？"><a href="#26-、你都做过哪些-Vue-的性能优化？" class="headerlink" title="26. 、你都做过哪些 Vue 的性能优化？"></a>26. 、你都做过哪些 Vue 的性能优化？</h1><p>这里只列举针对 Vue 的性能优化，整个项目的性能优化是一个大工程。</p><ul><li>对象层级不要过深，否则性能就会差。</li><li>不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）</li><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分场景使用</li><li>v-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if</li><li>大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格</li><li>防止内部泄露，组件销毁后把全局变量和时间销毁</li><li>图片懒加载</li><li>路由懒加载</li><li>异步路由</li><li>第三方插件的按需加载</li><li>适当采用 keep-alive 缓存组件</li><li>防抖、节流的运用</li><li>服务端渲染 SSR or 预渲染</li></ul><h1 id="27-、Vue-mixin-的使用场景和原理"><a href="#27-、Vue-mixin-的使用场景和原理" class="headerlink" title="27. 、Vue.mixin 的使用场景和原理"></a>27. 、Vue.mixin 的使用场景和原理</h1><p>在日常开发中，我们经常会遇到在不同组件中经常用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有相同名选项时，这些选项将以恰当的方式进行“合并”。</p><h1 id="28-、nextTick-使用场景和原理"><a href="#28-、nextTick-使用场景和原理" class="headerlink" title="28. 、nextTick 使用场景和原理"></a>28. 、nextTick 使用场景和原理</h1><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。</p><h1 id="29-、keep-alive-使用场景和原理"><a href="#29-、keep-alive-使用场景和原理" class="headerlink" title="29. 、keep-alive 使用场景和原理"></a>29. 、keep-alive 使用场景和原理</h1><p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><p>常用的两个属性 include/exclude，允许组件有条件的进行缓存。<br>两个生命周期 activated/deactivated，用来得知当前组件是否处理活跃状态。<br>keep-alive 运用了 LRU 算法，选择最近最久未使用的组件予以淘汰。<br>扩展补充：LRU 算法是什么？</p><h1 id="30-、Vue-set-方法原理"><a href="#30-、Vue-set-方法原理" class="headerlink" title="30. 、Vue.set 方法原理"></a>30. 、Vue.set 方法原理</h1><p>了解 Vue 响应式原理的同学都知道在两种情况下修改 Vue 是不会触发视图更新的。</p><ul><li>1、在实例创建之后添加新的属性到实例上（给响应式对象新增属性）</li><li>2、直接更改数组下标来修改数组的值。</li></ul><p>Vue.set 或者说是 $set 原理如下<br>因为响应式数据 我们给对象和数组本身新增了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪 然后会触发对象 <strong>ob</strong> 的dep收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组。</p><h1 id="31-、Vue-extend-作用和原理"><a href="#31-、Vue-extend-作用和原理" class="headerlink" title="31. 、Vue.extend 作用和原理"></a>31. 、Vue.extend 作用和原理</h1><p>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p><p>其实就是一个子类构造器，是Vue组件的核心api。实现思路就是使用原型继承的方法返回了 vue 的子类，并且利用 mergeOptions 把传入组件的 options 就和父类的 options 进行了合并。</p><h1 id="32-、写过自定义指令吗？原理是什么？"><a href="#32-、写过自定义指令吗？原理是什么？" class="headerlink" title="32. 、写过自定义指令吗？原理是什么？"></a>32. 、写过自定义指令吗？原理是什么？</h1><p>指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素添加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。</p><p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind</p><p>1、bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>2、inserted：被绑定元素插入父节点时调用。</p><p>3、update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较前后的绑定值。</p><p>4、componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</p><p>5、unbind：只调用一次，指令与元素解绑时调用。</p><p>原理：</p><p>1、在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</p><p>2、通过 genDirectives 生成指令代码</p><p>3、在 patch 前将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子。</p><p>4、当执行指令对应钩子函数时，调用对应指令定义方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="33-、Vue-修饰符有哪些？"><a href="#33-、Vue-修饰符有哪些？" class="headerlink" title="33. 、Vue 修饰符有哪些？"></a>33. 、Vue 修饰符有哪些？</h1><p><code>事件修饰符</code></p><ul><li>stop 阻止事件继续传播</li><li>.prevent 阻止标签默认行为</li><li>.capture 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理</li><li>.self 只当在 event.target 是当前元素自身时触发处理函数</li><li>.once 事件只会触发一次</li><li>.passive 告诉浏览器你不想阻止事件的默认行为</li></ul><p><code>v-model 的修饰符</code></p><ul><li>.lazy 通过这个修饰符，转变为在 change 事件再同步</li><li>.number 自动将用户输入值转化为数值类型</li><li>.trim 自动过滤用户输入的收尾空格</li></ul><p><code>键盘事件修饰符</code></p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li></ul><p><code>系统修饰符</code></p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta</li></ul><p><code>鼠标按钮修饰符</code></p><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h1 id="34-、Vue-模板编译原理"><a href="#34-、Vue-模板编译原理" class="headerlink" title="34. 、Vue 模板编译原理"></a>34. 、Vue 模板编译原理</h1><p>Vue 的编译过程就是将 template 转化为 render 函数的过程，分为以下三步：</p><ul><li>第一步是将 模板字符串转换成 element ASTs（解析器）</li><li>第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）</li><li>第三步是 使用element ASTs 生成 render 函数代码字符串（代码生成器）</li></ul><h1 id="35-、生命周期钩子是如何实现的"><a href="#35-、生命周期钩子是如何实现的" class="headerlink" title="35. 、生命周期钩子是如何实现的"></a>35. 、生命周期钩子是如何实现的</h1><p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的生命周期钩子订阅好（内部采用数组的方法存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p><h1 id="36-、函数式组件使用场景和原理"><a href="#36-、函数式组件使用场景和原理" class="headerlink" title="36. 、函数式组件使用场景和原理"></a>36. 、函数式组件使用场景和原理</h1><p>函数式组件与普通组件的区别</p><ul><li>1、函数式组件需要在声明组件时指定 functional:true</li><li>2、不需要实例化，所以没有this，this通过render函数的第二个参数context代替</li><li>3、没有生命周期钩子函数，不能使用计算属性，watch</li><li>4、不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件</li><li>5、因为函数组件时没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement</li><li>6、函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop，而普通的组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上（可以通过inheritAttrs属性禁止）</li></ul><p><code>优点</code>：</p><ul><li>1.由于函数组件不需要实例化，无状态，没有生命周期，所以渲染性要好于普通组件</li><li>2.函数组件结构比较简单，代码结构更清晰</li></ul><p><code>使用场景：</code></p><p>一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件。 “高阶组件”—用于接受一个组件为参数，返回一个被包装过的组件。<br>相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123; </span><br><span class="line">    <span class="comment">// 带有functional的属性的就是函数式组件 </span></span><br><span class="line">    <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> listeners = data.on;</span><br><span class="line">data.on = data.nativeOn; </span><br><span class="line">installComponentHooks(data); <span class="comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span></span><br></pre></td></tr></table></figure><h1 id="37-、能说下-vue-router-中常用的路由模式和实现原理吗？"><a href="#37-、能说下-vue-router-中常用的路由模式和实现原理吗？" class="headerlink" title="37. 、能说下 vue-router 中常用的路由模式和实现原理吗？"></a>37. 、能说下 vue-router 中常用的路由模式和实现原理吗？</h1><ul><li><p>hash 模式</p><ul><li><p>1、location.has 的值实际就是 URL 中 # 后面的东西。它的特点在于：hash虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</p></li><li><p>2、可以为 hash 的改变添加监听事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>,funcRef,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>每一次改变 hash (window.location.hash)，都会在浏览器的访问历史中增加一个记录，利用hash的以上特点，就可以实现前端路由“更新视图但不重新请求页面”的功能了</p><p><code>特点</code>：兼容性好但是不美观</p></li></ul></li><li><p>history 模式</p><p>  利用 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p><p>  这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础上，他们提供了对历史记录进行修改的功能。这两个方法有个共同点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础</p></li></ul><p><code>特点</code>：虽然美观，但是刷新会出现 404 需要后端进行配置。</p><h1 id="38-、diff-算法了解吗？"><a href="#38-、diff-算法了解吗？" class="headerlink" title="38. 、diff 算法了解吗？"></a>38. 、diff 算法了解吗？</h1><p>diff算法采用同级比较。</p><ul><li><p>1、tag 标签不一致直接新节点替换旧节点。</p></li><li><p>2、tag 标签一样。</p><ul><li><p>先替换属性</p></li><li><p>对比子元素<br>新老都有子元素，采用双指针方式进行对比<br>sameVnode 判断tag和key完全相同为同一节点，进行节点复用</p><ul><li>头和头相等对比</li><li>尾和尾相等对比</li><li>头和尾相等对比</li></ul><p>sameVnode 的时候传入两个新老子节点patch(oldChild,newChild)</p><p>乱序情况 – 上面的都不符合，</p><p>先遍历旧子节点数组形成 key值映射的map对象。<br>然后根据新子节点数组循环 按照key值和位置关系移动以及新增节点 最后删除多余的旧子节点 如果移动旧节点同样需要patch(oldChild,newChild)<br>新的有子元素，老的没有子元素。– 直接将子元素虚拟节点转化成真实节点插入即可。<br>新的没有子元素，老的有子元素。 – 直接清空 innerHtml<br>3、无 tag 标签 – 文本节点直接比较内容是否一致</p></li></ul></li></ul><h1 id="39-双向绑定"><a href="#39-双向绑定" class="headerlink" title="39. 双向绑定"></a>39. 双向绑定</h1><p>双向绑定可以分为三个问题</p><ul><li>Q：什么是双向绑定？</li></ul><p>我们先从单向绑定切入</p><p>单向绑定非常简单，就是把 Model 绑定到 View，当我们用 JavaScript 代码更新 Model 时，View 就会自动更新</p><p>双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了 View，Model 的数据也自动被更新了，这种情况就是双向绑定</p><p>当用户填写表单时，View 的状态就被更新了，如果此时可以自动更新 Model 的状态，那就相当于我们把 Model 和 View 做了双向绑定</p><p>关系图如下</p><ul><li><p>Q：双向绑定的原理是什么？</p><p>  我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</p><ul><li>数据层（Model）：应用的数据及业务逻辑</li><li>视图层（View）：应用的展示效果，各类 UI 组件</li><li>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来<br>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM</li></ul><p>  这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</p><p>  理解 ViewModel<br>  它的主要职责就是：</p><ul><li>数据变化后更新视图</li><li>视图变化后更新数据</li></ul><p>  当然，它还有两个主要部分组成</p><ul><li>监听器（Observer）：对所有数据的属性进行监听</li><li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li></ul></li><li><p>Q：实现双向绑定</p><p>  我们还是以 Vue 为例，先来看看 Vue 中的双向绑定流程是什么的.</p><p>  new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中；</p><p>  defineReactive 时为每⼀个 key 创建⼀个 Dep 实例,同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中；</p><p>  初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1,同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数</p><p>  由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher;由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中将来 data 中数据⼀旦发生变化,会首先找到对应的 Dep，通知所有 Watcher 执行更新函数；当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新.</p></li></ul><p><code>实现思路</code></p><p>defineReactive 时为每⼀个 key 创建⼀个 Dep 实例<br>初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1<br>由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中<br>当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新</p><h1 id="40-、Proxy-相比于-defineProperty-的优势"><a href="#40-、Proxy-相比于-defineProperty-的优势" class="headerlink" title="40. 、Proxy 相比于 defineProperty 的优势"></a>40. 、Proxy 相比于 defineProperty 的优势</h1><p>Object.defineProperty() 的问题主要有三个：</p><ul><li>不能监听数组的变化</li><li>必须遍历对象的每个属性</li><li>必须深层遍历嵌套的对象</li></ul><p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点：</p><ul><li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() </li><li>第二个问题支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li></ul><p>除了上述两点之外，Proxy 还拥有以下优势：</p><ul><li><p>Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get</span><br><span class="line">set</span><br><span class="line">construct,</span><br><span class="line">apply,</span><br><span class="line">deleteProperty,</span><br><span class="line">enumerate,</span><br><span class="line">ownKeys,</span><br><span class="line">has,</span><br><span class="line">defineProperty,</span><br><span class="line">getOwnPropertyDescriptor,</span><br><span class="line">isExtensible,</span><br><span class="line">preventExtensions,</span><br></pre></td></tr></table></figure></li><li><p>Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</p></li></ul><h1 id="41-、Vue与React的区别"><a href="#41-、Vue与React的区别" class="headerlink" title="41. 、Vue与React的区别"></a>41. 、Vue与React的区别</h1><ul><li>vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；</li><li>props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；</li><li>子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；</li><li>每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；</li><li>使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；</li><li>多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；</li><li>Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；</li><li>react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。<br>react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li><li>react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-mvc-%E5%92%8C-mvvm-%E5%8C%BA%E5%88%AB&quot;&gt;1. 、MVC 和 MVVM 区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E4%B8%BA%E4%BB%80%E4%B</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://hustchenshu.github.io/2022/04/16/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://hustchenshu.github.io/2022/04/16/%E8%B7%A8%E5%9F%9F/</id>
    <published>2022-04-16T09:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul><li><p>同源</p><p>所谓同源指的是两个页面具有相同的协议、主机和端口，三者有任一不相同即会产生跨域。</p></li><li><p>同源策略</p><p>  同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能。同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。更详细的说，是浏览器对在脚本内跨源发起的 http请求 的response结果进行了拦截。</p></li></ul><h1 id="可跨域场景"><a href="#可跨域场景" class="headerlink" title="可跨域场景"></a>可跨域场景</h1><ul><li>使用script标签加载非同源脚本</li><li>使用link标签加载非同源样式文件</li><li>使用img标签加载非同源图片</li><li>使用video、audio加载非同源媒体</li><li>使用object、embed、applet嵌入插件</li><li>使用@font-face引入非同源字体；</li><li>通过ifame载入非同源资源</li></ul><h1 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h1><h2 id="非同源http请求异常；"><a href="#非同源http请求异常；" class="headerlink" title="非同源http请求异常；"></a>非同源http请求异常；</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="开一个白名单"><a href="#开一个白名单" class="headerlink" title="开一个白名单"></a>开一个白名单</h4><ul><li>跨域资源共享（CORS）：  允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。</li></ul><h4 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h4><ul><li><p>反向代理（web不允许，找个中间商）</p><p>原理：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p></li><li><p>jsonp</p><p>原理： 利用标签没有跨域限制，通过标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p><p>缺点： 只能发送get请求。</p></li></ul><ul><li>window.name + iframewindow的name属性特征：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB），即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。</li></ul><h2 id="非同域iframe数据获取"><a href="#非同域iframe数据获取" class="headerlink" title="非同域iframe数据获取"></a>非同域iframe数据获取</h2><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><ul><li>window.name + iframe</li><li>location.hash + iframe</li><li>document.domain + iframe 跨子域</li><li>window跨源访问apiwindow.posMessage是可以跨源访问的api</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同源&lt;/p&gt;
&lt;p&gt;所谓同源指的是两个页面具有相同的协议、主机和端口，三者有任一不相同即会产生跨域。&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="浏览器" scheme="https://hustchenshu.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>rules_nodejs</title>
    <link href="https://hustchenshu.github.io/2022/03/19/rules_nodejs/"/>
    <id>https://hustchenshu.github.io/2022/03/19/rules_nodejs/</id>
    <published>2022-03-19T07:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rules-nodejs"><a href="#rules-nodejs" class="headerlink" title="rules_nodejs"></a>rules_nodejs</h1><p><a href="https://bazelbuild.github.io/rules_nodejs/Built-ins.html">原文</a></p><h2 id="Bazel-js-规则集"><a href="#Bazel-js-规则集" class="headerlink" title="Bazel js 规则集"></a>Bazel js 规则集</h2><p>Bazel js 规则集用于构建和测试js项目，包括nodejs和浏览器端；</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>规则集主要包含三个层：</p><ul><li>1.@rules_nodejs 模块，也是本规则集的核心模块（core），他包含了一个能够拉取独立的node/npm/yarn（取决于你的开发机器）环境的工具链，同时，也允许js规则之间的一些交互操作。这个对想要制作自己的的js环境的bazel rules开发人员是很有用的；</li><li>2.build_bazel_rules_nodejs模块，这个模块依赖于@rules_nodejs模块，在未来发布的版本中，这个模块的所有内容都将迁移到@rules_nodejs模块当中，移动到另一个仓库中，或者被废弃掉。这个模块提供了通过npm或者yarn安装第三方包的能力，BUILD文件将生成，以便于bazel可以加在第三方包的依赖图，并调用已安装工具的命令行。同时，本模块也支持运行nodejs程序等其他有用的规则。</li><li>3.一些自定义规则，通过名为@bazel的npm包发布。当规则集需要从peerDependency当中require包含js代码的包时，这些自定义规则是必须的，因为node的解析算法要求require的调用点必须在node_modules树当中。注意，我们不在接受新的npm包，建议这样的自定义规则放在独立的仓库当中。<ul><li><a href="https://www.npmjs.com/package/@bazel/concatjs">concatjs</a></li><li><a href="https://www.npmjs.com/package/@bazel/cypress">Cypress</a></li><li><a href="https://www.npmjs.com/package/@bazel/esbuild">esbuild</a></li><li><a href="https://www.npmjs.com/package/@bazel/jasmine">Jasmine</a></li><li><a href="https://www.npmjs.com/package/@bazel/karma">Karma</a></li><li><a href="https://www.npmjs.com/package/@bazel/labs">Labs</a></li><li><a href="https://www.npmjs.com/package/@bazel/protractor">Protractor</a></li><li><a href="https://www.npmjs.com/package/@bazel/rollup">Rollup</a></li><li><a href="https://www.npmjs.com/package/@bazel/terser">Terser</a></li><li><a href="https://www.npmjs.com/package/@bazel/typeScript">TypeScript</a></li></ul></li></ul><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p>我们的目标是是bazel成为现有npm工具上的最小分层，并且与这些工具做到最大兼容。</p><p>这意味着我们不会争论webpack还是Rollup，你可以通过bazel使用任何你喜欢的工具，实际上，我们推荐你保持现有的工具，那样你就只需要专注于做bazel迁移的工作了。</p><p>在很多情况下，我们需要权衡取舍，我们不会为开发者做任何决策，因为我们提供给了许多方式，而不是像许多其他js打包工具一样指定某个“最好”的方式。当然，这会增加这些规则的理解难度和复杂度，但是也避免了选择错误的“赢家”。例如，你可以自己安装依赖，或者让bazel管理依赖项副本，或者让bazel链接到项目中的项目。</p><p>js生态系统充满了错误等价观点，我们经常遇到的就是webpack和bazel那个更好？这都是可以理解的，毕竟大多数js工具都被迫搭建一个孤立的插件系统提供一条龙服务，而且人类喜欢争锋相对的竞争。相反的，bazel只是编排调用这些方法。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>首先，我们闯将一个工作区（workspace），其实也就是一个目录，我们可以通过@bazel/create的npm包来创建，这对于我们大多数人来说是最快的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm init @bazel my_workspace</span><br><span class="line">cd my_workspace</span><br><span class="line"></span><br><span class="line"><span class="comment">// yarn</span></span><br><span class="line">yarn create @bazel my_workspace</span><br><span class="line">cd my_workspace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些指令等同于npx @bazel/create，将会下载最新的@bazel/create包并运行其中的程序</span></span><br></pre></td></tr></table></figure><p>接下来，我们安装一些开发工具。比如我们需要babel来转译我们的js代码，需要mocha来跑单元测试，需要http-server来启动我们的应用，这些都是任意可选的，你可以使用你喜欢的任何东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/core @babel/cli @babel/preset-env http-server mocha domino</span><br></pre></td></tr></table></figure><p>让我们用bazel来运行这些工具，有两种运行工具的方法：</p><ul><li>通过导入npm包当中的index.bzl自动生成bazel rule；</li><li>自己编写或者使用rule_nodejs当中的自定义规则；</li></ul><p>在当前这个例子当中，我们使用自动生成的方法。首先我们需要导入他们，使用load描述，在BUILD.bazel中编辑添加如下代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load(&quot;@npm//@babel/cli:index.bzl&quot;, &quot;babel&quot;)</span><br><span class="line">load(&quot;@npm//mocha:index.bzl&quot;, &quot;mocha_test&quot;)</span><br><span class="line">load(&quot;@npm//http-server:index.bzl&quot;, &quot;http_server&quot;)</span><br></pre></td></tr></table></figure><p><code>这向我们展示了rules_nodejs已经告诉bazel一个名为@npm的工作空间是可用的，rules_nodejs将添加index.bzl暴露出该npm包安装的所有二进制文件，我们安装的三个工具都在@npm范围内，每个工具包都有一个扩展名为.bzl的文件</code></p><p>接下来，我们教bazel如何将我们的js输入代码转译成需要的输出文件。这里我们假设你的项目里有app.js、es5.babelrc文件，请参阅我们的示例<a href="https://github.com/bazelbuild/rules_nodejs/tree/1.4.0/examples/webapp">webapp</a>,现在我们想要babel生成app.es5.js，所以我们添加BUILD.bazel如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">babel(</span><br><span class="line">    name = &quot;compile&quot;,</span><br><span class="line">    data = [</span><br><span class="line">        &quot;app.js&quot;,</span><br><span class="line">        &quot;es5.babelrc&quot;,</span><br><span class="line">        &quot;@npm//@babel/preset-env&quot;,</span><br><span class="line">    ],</span><br><span class="line">    outs = [&quot;app.es5.js&quot;],</span><br><span class="line">    args = [</span><br><span class="line">        &quot;app.js&quot;,</span><br><span class="line">        &quot;--config-file&quot;,</span><br><span class="line">        &quot;./$(execpath es5.babelrc)&quot;,</span><br><span class="line">        &quot;--out-file&quot;,</span><br><span class="line">        &quot;$(execpath app.es5.js)&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>这里仅仅调用了babel的命令行工具，你可以查看他们的文档了解需要传递的参数，我们在bazel中使用$(execpath)来帮助我们标识路径，这样便不需要硬编码我们的输入输出路径了。</code></p><p>现在我们可以通过运行<code>npm run build</code>来构建我们的应用了。<br>我们可以看到babel的.js输出出现在dist/bin文件夹中。<br>让我们通过添加以下内容到BUILD.bazel来看看我们的页面长什么样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http_server(</span><br><span class="line">    name = <span class="string">&quot;server&quot;</span>,</span><br><span class="line">    data = [</span><br><span class="line">        <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;app.es5.js&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    args = [<span class="string">&quot;.&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在package.json当中添加一个serve脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;ibazel run :server&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ibazel是bazel的watch模式，注意，在windows上，你需要添加--enable_runfile参数给bazel，因为bazel会创建一个目录用来方便统一存放输入和输出文件</code></p><p>现在我们可以启动serve了： <code>npm run serve</code></p><p>最后，我们将使用mocha并添加测试，添加dimino包这样就不用浏览器环境了，在BUILD.bazel添加如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mocha_test(</span><br><span class="line">    name = <span class="string">&quot;unit_tests&quot;</span>,</span><br><span class="line">    args = [<span class="string">&quot;*.spec.js&quot;</span>],</span><br><span class="line">    data = glob([<span class="string">&quot;*.spec.js&quot;</span>]) + [</span><br><span class="line">        <span class="string">&quot;@npm//domino&quot;</span>,</span><br><span class="line">        <span class="string">&quot;app.es5.js&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行测试： <code>npm test</code>；</p><h2 id="rules-nodejs-1"><a href="#rules-nodejs-1" class="headerlink" title="@rules_nodejs"></a>@rules_nodejs</h2><p>这是核心模块，被内部的build_bazel_rules_nodejs模块引用，许多用户应该继续使用后者，忽略这个核心模块。</p><p>他们的依赖图是<code>build_bazel_rules_nodejs -&gt; rules_nodejs -&gt; bazel_skylib</code></p><p>特点：</p><ul><li>一个能根据开发者的机器拉取独立node、npm、yarn副本的工具链；</li><li>核心模块提供js规则之间交互的能力；</li></ul><h3 id="directory-file-path"><a href="#directory-file-path" class="headerlink" title="directory_file_path"></a>directory_file_path</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory_file_path(name, directory, path)</span><br></pre></td></tr></table></figure><p>提供文件目录路径信息来引用指定文件下的文件（否则没有办法给他一个bazel标签）</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>name</code><br>当前target中唯一的一个名字</p><p><code>directory</code><br>一个目录</p><p><code>path</code><br>目录下的路径</p><h3 id="node-repositories"><a href="#node-repositories" class="headerlink" title="node_repositories"></a>node_repositories</h3><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_repositories(name, node_download_auth, node_repositories, node_urls, node_version, platform,</span><br><span class="line">                  repo_mapping, use_nvmrc)</span><br></pre></td></tr></table></figure><p>在用户的WORKSPACWE当中运行，安装rules_nodejs依赖项。</p><p>此规则用于设置node、npm和npx，他们的版本号可以通过以下三种方法设置：</p><ul><li>最简单的用法</li></ul><p>不指定显式版本。这将会下载并使用当前使用的rules_nodejs可用的最新的nodejs版本。请注意，如果你稍后会使用yarn_install或者npm_install，你可以跳过node_repositories的调用，我们会为你自动选择最简单的用法。</p><ul><li>强制指定版本</li></ul><p>你可以通过在调用时传入与已知版本匹配的值，来指定nodejs的下载版本。</p><ul><li>使用自定义版本</li></ul><p>你可以传入nodejs版本的库和下载地址列表来指定要使用的node环境。</p><p>你可以使用如下方式指定自定义nodejs版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node_repositories(</span><br><span class="line">    node_repositories = &#123;</span><br><span class="line">        <span class="string">&quot;10.10.0-darwin_amd64&quot;</span>: (<span class="string">&quot;node-v10.10.0-darwin-x64.tar.gz&quot;</span>, <span class="string">&quot;node-v10.10.0-darwin-x64&quot;</span>, <span class="string">&quot;00b7a8426e076e9bf9d12ba2d571312e833fe962c70afafd10ad3682fdeeaa5e&quot;</span>),</span><br><span class="line">        <span class="string">&quot;10.10.0-linux_amd64&quot;</span>: (<span class="string">&quot;node-v10.10.0-linux-x64.tar.xz&quot;</span>, <span class="string">&quot;node-v10.10.0-linux-x64&quot;</span>, <span class="string">&quot;686d2c7b7698097e67bcd68edc3d6b5d28d81f62436c7cf9e7779d134ec262a9&quot;</span>),</span><br><span class="line">        <span class="string">&quot;10.10.0-windows_amd64&quot;</span>: (<span class="string">&quot;node-v10.10.0-win-x64.zip&quot;</span>, <span class="string">&quot;node-v10.10.0-win-x64&quot;</span>, <span class="string">&quot;70c46e6451798be9d052b700ce5dadccb75cf917f6bf0d6ed54344c856830cfb&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这些将被映射成下面的使用node_urls表示的自定义下载url：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node_repositories(</span><br><span class="line">    node_version = <span class="string">&quot;10.10.0&quot;</span>,</span><br><span class="line">    node_repositories = &#123;<span class="string">&quot;10.10.0-darwin_amd64&quot;</span>: (<span class="string">&quot;node-v10.10.0-darwin-x64.tar.gz&quot;</span>, <span class="string">&quot;node-v10.10.0-darwin-x64&quot;</span>, <span class="string">&quot;00b7a8426e076e9bf9d12ba2d571312e833fe962c70afafd10ad3682fdeeaa5e&quot;</span>)&#125;,</span><br><span class="line">    node_urls = [<span class="string">&quot;https://mycorpproxy/mirror/node/v&#123;version&#125;/&#123;filename&#125;&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么，mac客户端将尝试从下载节点：<code>https://mycorpproxy/mirror/node/v10.10.0/node-v10.10.0-darwin-x64.tar.gz</code>进行下载，并期望该文件具有的sha256sum为：<code>00b7a8426e076e9bf9d12ba2d571312e833fe962c70afafd10ad3682fdeeaa5e</code></p><ul><li>使用自定义node.js</li></ul><p>为避免下载，你可以使用构建好的二进制包，或者直接从源代码构建，可以参看<a href="https://bazelbuild.github.io/rules_nodejs/toolchains.md">工具链</a>和examples/vendored_node_and_yarn.</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>name</code><br>当前target中唯一的一个名字</p><p><code>node_download_auth</code><br>用于所有url请求的身份验证，示例：<code> &#123;“type”: “basic”, “login”: “&quot;, &quot;password&quot;: &quot;&quot; &#125;</code><br>默认为：<code>&#123;&#125;</code></p><p><code>node_repositories</code><br>要使用的node仓库<br>默认为：<code>&#123;&#125;</code></p><p><code>node_urls</code></p><p><code>node_version</code></p><p><code>platform</code></p><p><code>repo_mapping</code></p><p><code>use_nvmrc</code></p><h2 id="build-bazel-rules-nodejs"><a href="#build-bazel-rules-nodejs" class="headerlink" title="@build_bazel_rules_nodejs"></a>@build_bazel_rules_nodejs</h2><h2 id="bazel-npm扩展包"><a href="#bazel-npm扩展包" class="headerlink" title="@bazel npm扩展包"></a>@bazel npm扩展包</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rules-nodejs&quot;&gt;&lt;a href=&quot;#rules-nodejs&quot; class=&quot;headerlink&quot; title=&quot;rules_nodejs&quot;&gt;&lt;/a&gt;rules_nodejs&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://bazelbuild.gi</summary>
      
    
    
    
    <category term="实践" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="仓库管理， bazel" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%EF%BC%8C-bazel/"/>
    
    
    <category term="工程实践" scheme="https://hustchenshu.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="bazel" scheme="https://hustchenshu.github.io/tags/bazel/"/>
    
    <category term="rules_nodejs" scheme="https://hustchenshu.github.io/tags/rules-nodejs/"/>
    
    <category term="api翻译" scheme="https://hustchenshu.github.io/tags/api%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>BFC与清除浮动</title>
    <link href="https://hustchenshu.github.io/2022/03/19/bfc/"/>
    <id>https://hustchenshu.github.io/2022/03/19/bfc/</id>
    <published>2022-03-19T05:55:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFbfc">1. 什么是BFC</a><ul><li><a href="#11-%E5%AE%9A%E4%B9%89">1.1. 定义</a></li><li><a href="#12-%E6%9D%A1%E4%BB%B6%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90bfc">1.2. 条件（如何形成bfc）</a></li><li><a href="#13-%E7%89%B9%E6%80%A7">1.3. 特性</a></li><li><a href="#14-%E5%BA%94%E7%94%A8">1.4. 应用</a><ul><li><a href="#141-%E9%81%BF%E5%85%8Dmargin%E9%87%8D%E5%8F%A0">1.4.1. 避免margin重叠</a></li><li><a href="#142-%E4%B8%A4%E6%A0%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80float">1.4.2. 两栏自适应布局（float）</a></li><li><a href="#143-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8">1.4.3. 清除浮动</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="1-什么是BFC"><a href="#1-什么是BFC" class="headerlink" title="1. 什么是BFC"></a>1. 什么是BFC</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h2><p><code>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</code></p><ul><li>Box 是 CSS 布局的对象和基本单位，Box的类型由元素的类型和display属性决定。主要分为block-level box和inline-level box两种box类型：block/list/table等元素会生成box-level box，而inline/inline-blck/inline-table等生成inline-box；</li></ul><h2 id="1-2-条件（如何形成bfc）"><a href="#1-2-条件（如何形成bfc）" class="headerlink" title="1.2. 条件（如何形成bfc）"></a>1.2. 条件（如何形成bfc）</h2><ul><li>当前元素为根元素；</li><li>float属性不为none；</li><li>overflow不为visible；</li><li>position不为static或者relative；</li><li>display的值为flex/inline-block/inline-flex/table-cell/table-caption</li></ul><h2 id="1-3-特性"><a href="#1-3-特性" class="headerlink" title="1.3. 特性"></a>1.3. 特性</h2><ul><li>内部的元素会在垂直方向，从顶部开始一个接一个地放置。 </li><li>元素垂直方向的距离由margin决定。属于同一个BFC的两个相邻 元素的margin会发生叠加</li><li>都是从最左边开始的。每个元素的margin box的左边，与包含块border box的左边(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li><li>BFC的区域不会与float box叠加。 </li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。 </li><li>浮动元素也参与计算BFC的高度计算（当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包<br>括浮动元素的高度）；</li><li>文字层不会被浮动层覆盖，环绕于周围；</li></ul><h2 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4. 应用"></a>1.4. 应用</h2><h3 id="1-4-1-避免margin重叠"><a href="#1-4-1-避免margin重叠" class="headerlink" title="1.4.1. 避免margin重叠"></a>1.4.1. 避免margin重叠</h3><p>两个元素在同一个bfc内且垂直相邻，那么两者之间的margin会相互重叠，可以让两个元素分别形成各自的bfc，避免margin重叠；</p><h3 id="1-4-2-两栏自适应布局（float）"><a href="#1-4-2-两栏自适应布局（float）" class="headerlink" title="1.4.2. 两栏自适应布局（float）"></a>1.4.2. 两栏自适应布局（float）</h3><p>bfc内左侧box使用float，此时左侧和右侧属于同一个bfc，两者左侧对其，要使得右侧box接在左侧box后面，需要右侧box形成单独bfc，这样右侧bfc不与左侧float box重叠，自然接在左侧box后面；</p><h3 id="1-4-3-清除浮动"><a href="#1-4-3-清除浮动" class="headerlink" title="1.4.3. 清除浮动"></a>1.4.3. 清除浮动</h3><ul><li><p>浮动带来的问题</p><ul><li>子容器浮动，父容器高度塌陷</li><li>浮动元素脱离文档流，对后面元素布局产生影响；</li></ul></li><li><p>如何清除</p><ul><li>clear，浮动元素前后的兄弟元素添加clear元素，强制规定其左右不能存在浮动元素，从而隔离float元素对其的影响<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">MDN:clear</a>；</li><li>形成父级bfc；包含浮动元素的父容器形成bfc，则父容器包含float box；</li><li>设定父容器高度；          </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E4%BB%80%E4%B9%88%E6%98%AFbfc&quot;&gt;1. 什么是BFC&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E5%AE%9A%E4%B9%89&quot;&gt;1.1. 定义&lt;/a&gt;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="css" scheme="https://hustchenshu.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://hustchenshu.github.io/tags/css/"/>
    
    <category term="bfc" scheme="https://hustchenshu.github.io/tags/bfc/"/>
    
  </entry>
  
  <entry>
    <title>构建系统进程浅析</title>
    <link href="https://hustchenshu.github.io/2021/11/07/%E5%A4%A7%E4%BB%93%E7%AE%A1%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hustchenshu.github.io/2021/11/07/%E5%A4%A7%E4%BB%93%E7%AE%A1%E7%90%86%E6%8E%A2%E7%B4%A2/</id>
    <published>2021-11-07T07:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是构建系统？对于前端工程师来说，最常见的可能是一些打包工具，比如webpack，rollup等等，这些可以称得上最简单的构建系统了，更为广泛一点，构建系统就是将程序员编写的源代码通过一系列的工具转化成可使用的产物，可能是手机app，也可能是服务器镜像或者是bundle页面文件。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>一个优秀的构建系统，除了要完成上面所说的生成构建产物的基本功能，还需要满足下面这些要求“</p><ul><li><p>唯一准确性</p><p>  对于相同的源代码，应当生成完全一致的工程产物，不应受构建平台、构建环境等其他因素的影响。</p></li><li><p>快速性</p><p>  构建系统构建效率应当响应迅速，不能够影响开发人员的开发效率。</p></li></ul><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>随着前端项目越来越复杂，前端项目仓库的规模越来越大，仓库的管理、产物的构建也成了很多困扰工程师们的大问题，开始构建，然后喝杯咖啡再来看构建结果，构建失败再来一杯，这样极大影响了构建效率。</p><p>从仓库组织方式来看，目前解决这类问题主要是两个流派：</p><ul><li>multirepo</li><li>monorepo</li></ul><p><img src="https://raw.githubusercontent.com/hustchenshu/hustchenshu.github.io/master/source/images/muti-vs-mono.png" alt="muti vs mono"></p><p>从构建角度来看，也是两个流派</p><ul><li><p>基于任务的构建系统（Task-Based Build Systems）<br>  最基本的工作单位是“任务“。每一个任务都是一个能执行任何逻辑的脚本，而每个任务都会把其它一些任务作为依赖(dependencies)，而要求必须在它们自己之前运行。</p><p>  <strong>缺点</strong></p><ul><li>无法并发</li><li>无法增量构建</li><li>维护和调试困难</li></ul></li><li><p>基于制品的构建系统(Artifact-Based Build Systems)<br>  基于任务的构建系统给了程序员太大的权力去定义他们自己的任务。实际上，与其让程序员自己去定义任务，不如让系统定义一组任务，然后由程序员在受限的情况下进行配置，这样保持了每一个构建过程的确定性。将命令式的构建过程变成了声明式。</p></li></ul><h2 id="多仓管理-multirepo"><a href="#多仓管理-multirepo" class="headerlink" title="多仓管理(multirepo)"></a>多仓管理(multirepo)</h2><p>最开始的针对规模不断扩大的仓库，主要有两条思路：<br><code>思路一是化繁为简，化大为小</code>,将整个仓库进行拆分，把大仓库根据功能或者业务划分为一个个小仓，然后根据一定的方式把这些小仓库组织起来，于是multirepo诞生了，multirepo让每个仓库能够拥有自己的依赖，打包方式，开阿法流水线，不同的团队可以使用各自熟悉的方式组织各自业务仓库。组织方式也有很多种，比如下面这些：</p><h3 id="git-repo"><a href="#git-repo" class="headerlink" title="git-repo"></a>git-repo</h3><p>git-repo简称Repo，是基于Git的一款工具，可以管理多个Git库，从而使开发流程的自动化。<br>repo命令其实是一个Python脚本。</p><p>初始化的时候会添加.repo/manifests文件来和.repo/manifest.xml文件,manifest.xml是指向 .repo/manifests/ 目录中所选清单的符号链接。类似于git当中每一个commit是有一个快照的，这里是一系列仓库的快照集合。</p><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git-submodule"></a>git-submodule</h3><p>使用场景：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p><p>添加子模块的时候会添加.gitmodules 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;DbConnector&quot;]</span><br><span class="line">path = DbConnector</span><br><span class="line">url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure><h3 id="gitslave"><a href="#gitslave" class="headerlink" title="gitslave"></a>gitslave</h3><p>Gitslave是一个用于大型项目的协调版本控制的脚本，该脚本使用Git结合了来自多个独立存储库的代码。 gitslave比传统的git submodule更加灵活，它为命令行git提供了一个简单的包装器，该包装器管理带有“主” git存储库的子目录中的多个辅助（“ slave”）git存储库的目录树。 从“ gits”包装器运行的任何git命令都将在所有git存储库中执行； 例如gits checkout -b newbranch将在所有存储库中创建新分支。 </p><h3 id="git-subtree"><a href="#git-subtree" class="headerlink" title="git-subtree"></a>git-subtree</h3><p>git subtree与git submodule不同，它不增加任何像.gitmodule这样的新的元数据文件.<br>git subtree对于项目中的其他成员透明，意味着可以不知道git subtree的存在.</p><p>缺点：<br>必须学习新的指令(如：git subtree).<br>子仓库的更新与推送指令相对复杂。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>组织灵活</p></li><li><p>单个仓库体积小</p></li><li><p>项目间低耦合</p></li><li><p>标准，规范不统一</p></li><li><p>沟通交接困难</p></li><li><p>依赖维护困难</p></li><li><p>项目间难以复用，重复性工作</p></li></ul><h2 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h2><h3 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h3><p>将代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel、 React、Angular、Ember、Meteor、Jest 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。</p><h3 id="buck-FaceBook"><a href="#buck-FaceBook" class="headerlink" title="buck(FaceBook)"></a>buck(FaceBook)</h3><h3 id="pants-Twitter"><a href="#pants-Twitter" class="headerlink" title="pants(Twitter)"></a>pants(Twitter)</h3><h3 id="bazel"><a href="#bazel" class="headerlink" title="bazel"></a>bazel</h3><p>Bazel是google内部构建工具Blaze的开源实现，也是一个基于artifact的构建系统的优秀示例，bazel使用mutirepo的仓库组织形式</p><p><strong>基本概念</strong></p><ul><li><p>工作区(Workspace)</p><p>  工作区是构建你想得到的产物所需源代码所在的文件系统，它包含有一个WOKESPACE文件（可为空），文件声明了构建所需的其他外部依赖</p></li><li><p>包(Packages)</p><p>  在工作区中,最主要的代码组织单元就是包. 包就是一组相关的文件和它们之间依赖关系的一种规范.包里面有一个BUILD文件，定义该包的构建输入和输出制品</p></li><li><p>目标(Targets)</p><p>  包是一个容器, 组成包的元素叫做目标(targets). 大多数目标(targets) 属于文件和规则。</p></li><li><p>标签(Labels)</p><p>  所有的target都属于一个包, 包的名称叫做标签. 每个标签有两部分组成: 包的名称(my/app/main)和目标名称(app_binary). 每一个标签唯一标识一个目标. 一个经典的标签的规范形式如下所示:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//my/app/main:app_binary</span><br></pre></td></tr></table></figure></li><li><p>规则(Rules)</p><p>  规则指定了输入和输出之间的关系, 还有构建输出的步骤.规则可以是许多不同种类或类别之一，它们生成编译的可执行文件和库</p></li><li><p>BUILD文件</p><p>  每个包都包含一个BUILD文件，这是一个用构建语言编写的简短程序。 大多数BUILD文件似乎只是一系列构建规则的声明; 确实，在编写BUILD文件时，强烈地鼓励声明方式。使用的语言为<a href="https://github.com/bazelbuild/starlark/">starlark</a></p><p>  Starlark 是Python的一种方言。与 Python 一样，它是一种动态类型语言，他是为bazel构建系统而生的一种声明式语言。</p></li></ul><p><strong>构建流程</strong></p><ul><li>解析当前workspace中每一个build文件，创建各个artifacts之间的依赖图；</li><li>根据生成的artifacts依赖图确定整个各个构建流程的依赖转换关系；</li><li>根据build文件定义，按顺序构建每一个依赖：首先构建没有任何依赖的target，并跟踪对于每个target还有哪些依赖需要构建，一旦一个target所有依赖构建之后，bazel开始构建改target，该过程一致持续到每一个依赖被构建完成；</li><li>链接已生成的所有有依赖，生成最终制品；</li></ul><p><strong>改进</strong></p><p>相比基于任务的构建系统，有哪些改进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数式编程模式（每一个依赖构建都是有确定的输入输出） </span><br><span class="line">=&gt; 可获取依赖图 </span><br><span class="line">=&gt; </span><br><span class="line">可并行构建（无依赖关联的target构建可并行）</span><br><span class="line">可增量构建（只要输入不变，输出结果就可以被重用）</span><br></pre></td></tr></table></figure><p><strong>通过减少暴露给程序员的灵活性，构建系统能够知道每一步到底在做什么，从而能够用这些信息来帮助构建通过并发和重用机制更加高效。</strong></p><p><strong>其他特性：</strong></p><ul><li>对工具的依赖(Tools as dependencies)</li><li>扩展构建系统(Extending the build system)</li><li>环境隔离(Isolating the environment)</li><li>可确定的外部依赖(Making external dependencies deterministic)</li><li>分布式构建(Distributed Builds)<ul><li>远程缓存(Remote Caching)</li><li>远程执行(Remote Execution)</li></ul></li><li>…..</li></ul><p><strong>demo</strong></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://github.com/bazelbuild/rules_nodejs">rules_nodejs</a></li><li><a href="https://docs.bazel.build/versions/4.2.2/bazel-overview.html">docs.bazel</a></li><li><a href="https://zhuanlan.zhihu.com/p/262171925">bazel入门</a></li><li><a href="https://github.com/bazelbuild/starlark/">starlark</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构建系统&quot;&gt;&lt;a href=&quot;#构建系统&quot; class=&quot;headerlink&quot; title=&quot;构建系统&quot;&gt;&lt;/a&gt;构建系统&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h</summary>
      
    
    
    
    <category term="实践" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="仓库管理" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="工程实践" scheme="https://hustchenshu.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>浏览器基础知识</title>
    <link href="https://hustchenshu.github.io/2021/07/17/browser/"/>
    <id>https://hustchenshu.github.io/2021/07/17/browser/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="browser"><a href="#browser" class="headerlink" title="browser"></a>browser</h1><ul><li><a href="#browser">browser</a><ul><li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li><li><a href="#http">HTTP</a></li><li><a href="#%E6%9E%84%E5%BB%BAdom%E6%A0%91">构建dom树</a></li><li><a href="#%E6%B7%BB%E5%8A%A0css%E6%A0%B7%E5%BC%8F%E7%94%9F%E6%88%90cssom">添加css样式，生成cssom</a></li><li><a href="#%E5%B8%83%E5%B1%80reflow">布局（reflow）</a></li><li><a href="#paint">paint</a></li><li><a href="#reference">reference</a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2></li></ul></li></ul><p>对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/browser-pipeline.jpg" alt="browser-pipeline"></p><ul><li>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</li><li>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</li><li>计算 DOM 树上的 CSS 属性；</li><li>最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</li><li>合成之后，再绘制到界面上。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><a href="./HTTP.md">HTTP</a></h2><h2 id="构建dom树"><a href="#构建dom树" class="headerlink" title="构建dom树"></a>构建dom树</h2><p>解析请求回来的 HTML 代码，构建dom树。</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/dom-token-analyse.png" alt="dom-token-analyse"></p><ul><li><p>词法分析器接收到的字符流，通过分析（状态机/正则）被拆分为一个个token；</p></li><li><p>语法分析器对解析得到的token分析，构建dom树；</p></li></ul><h2 id="添加css样式，生成cssom"><a href="#添加css样式，生成cssom" class="headerlink" title="添加css样式，生成cssom"></a>添加css样式，生成cssom</h2><p>在构建dom树的同时，浏览器也会流式的同步计算css属性：检查生成的dom节点匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。</p><p><strong>cssom是有rule部分和view部分的，rule部分是在dom开始之前就构件完成的，而view部分是跟着dom同步构建的。</strong></p><h2 id="布局（reflow）"><a href="#布局（reflow）" class="headerlink" title="布局（reflow）"></a>布局（reflow）</h2><p>构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素。等所有元素生成完成，计算每个元素的大小和位置信息。</p><h2 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h2><p>将计算好的渲染树，最终显示到屏幕上，分为渲染、合成、绘制三个部分；</p><p>渲染过程把元素变成位图，合成把一部分位图变成合成层，绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，在这之前可能还会有合成等优化步骤。</p><p><strong>合成（compositing）</strong><br>合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。</p><p>最后的步骤：把模型变成位图的过程，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://stackoverflow.com/questions/598841/how-to-get-started-building-a-web-browser">https://stackoverflow.com/questions/598841/how-to-get-started-building-a-web-browser</a></li><li><a href="https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html">https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html</a> </li><li><a href="https://github.com/joegesualdo/abbott">https://github.com/joegesualdo/abbott</a> </li><li><a href="https://github.com/cytle/toy-browser">https://github.com/cytle/toy-browser</a> </li><li><a href="https://github.com/ryanmcdermott/dumbkit">https://github.com/ryanmcdermott/dumbkit</a> </li><li><a href="https://github.com/aimergenge/toy-html-parser">https://github.com/aimergenge/toy-html-parser</a> </li><li><a href="https://github.com/mbrubeck/robinson">https://github.com/mbrubeck/robinson</a></li><li><a href="https://github.com/maekawatoshiki/naglfar">https://github.com/maekawatoshiki/naglfar</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;browser&quot;&gt;&lt;a href=&quot;#browser&quot; class=&quot;headerlink&quot; title=&quot;browser&quot;&gt;&lt;/a&gt;browser&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#browser&quot;&gt;browser&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="浏览器" scheme="https://hustchenshu.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://hustchenshu.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>代码规范</title>
    <link href="https://hustchenshu.github.io/2021/07/17/commit-and-changelog/"/>
    <id>https://hustchenshu.github.io/2021/07/17/commit-and-changelog/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&quot;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="实践" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="代码规范" scheme="https://hustchenshu.github.io/categories/%E5%AE%9E%E8%B7%B5/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="代码规范" scheme="https://hustchenshu.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    <category term="commit" scheme="https://hustchenshu.github.io/tags/commit/"/>
    
    <category term="changelog" scheme="https://hustchenshu.github.io/tags/changelog/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="https://hustchenshu.github.io/2021/07/17/css/"/>
    <id>https://hustchenshu.github.io/2021/07/17/css/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。</p><p>at-rule 由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。</p><p>qualified rule 则是指普通的 CSS 规则，也就是我们所熟识的，由选择器和属性指定构成的规则。</p><h3 id="at-规则"><a href="#at-规则" class="headerlink" title="at 规则"></a>at 规则</h3><ul><li><a href="https://www.w3.org/TR/css-syntax-3/">@charset</a></li></ul><p>@charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css-cascade-4/">@import</a></li></ul><p>@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;mystyle.css&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;mystyle.css&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css3-conditional/">@media</a></li></ul><p>media 就是大名鼎鼎的 media query 使用的规则了，它能够对设备的类型进行一些判断。在 media 的区块内，是普通规则列表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">10pt</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css-page-3/">@page</a></li></ul><p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p><ul><li><a href="https://www.w3.org/TR/css-counter-styles-3">@counter-style</a></li></ul><p>counter-style 产生一种数据，用于定义列表项的表现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@counter-style</span> triangle &#123;</span><br><span class="line">  system: cyclic;</span><br><span class="line">  symbols: ‣;</span><br><span class="line">  suffix: <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css-animations-1/">@keyframes</a></li></ul><p>keyframes 产生一种数据，用于定义动画关键帧。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> diagonal-slide &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css-fonts-3/">@fontface</a></li></ul><p>fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Gentium;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">http://example.com/fonts/Gentium.woff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-family</span>: Gentium, serif; &#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.w3.org/TR/css3-conditional/">@supports</a></li></ul><p>support 检查环境的特性，它与 media 比较类似。</p><ul><li><a href="https://www.w3.org/TR/css-namespaces-3/">@namespace</a></li></ul><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p><h3 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h3><ul><li>普通规则<ul><li>选择器</li><li>声明列表<ul><li>属性</li><li>值<ul><li>值的类型</li><li>函数</li></ul></li></ul></li></ul></li></ul><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a href="https://www.w3.org/TR/selectors-4/">选择器</a></h4><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/css-selector.png" alt="selector"></p><ul><li><strong>简单选择器</strong></li></ul><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/simple-selector.png" alt="simple"></p><ul><li><strong>选择器的组合</strong></li></ul><p>选择器列表是用逗号分隔的复杂选择器序列；复杂选择器则是用空格、大于号、波浪线等符号连接的复合选择器；复合选择器则是连写的简单选择器组合。</p><p>根据选择器列表的语法，选择器的连接方式可以理解为像四则运算一样有优先级。</p><ul><li><p>第一优先级</p><ul><li>无连接符号</li></ul></li><li><p>第二优先级</p><ul><li>“空格”</li><li>“~”</li><li>“+”</li><li>“&gt;”</li><li>“||”</li></ul></li><li><p>第三优先级</p><ul><li>“,”</li></ul></li><li><p><strong>选择器的优先级</strong></p></li></ul><p>CSS 标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。</p><ul><li>id 选择器的数目记为 a；</li><li>伪类选择器和 class 选择器的数目记为 b；</li><li>伪元素选择器和标签选择器数目记为 c；</li><li>“*” 不影响优先级。</li></ul><p>CSS 标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specificity = base * base * a + base * b + c</span><br></pre></td></tr></table></figure><p><strong>行内属性的优先级永远高于 CSS 规则，浏览器提供了一个“口子”，就是在选择器前加上“!import”。</strong></p><p><strong>同一优先级的选择器遵循“后面的覆盖前面的”原则</strong></p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>声明部分是一个由“属性: 值”组成的序列。</p><p><strong>属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">color</span>: <span class="number">#06c</span>;</span><br><span class="line">  --accent-<span class="attribute">color</span>: <span class="number">#006</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The rest of the CSS file */</span></span><br><span class="line"><span class="selector-id">#foo</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="正常流"><a href="#正常流" class="headerlink" title="正常流"></a>正常流</h4><p>我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理：</p><ul><li>当遇到块级盒：排入块级格式化上下文。</li><li>当遇到行内级盒或者文字：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。</li><li>遇到 float 盒：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据 float 的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。</li></ul><p>一些元素会在其内部创建新的块级格式化上下文，这些元素有：</p><ul><li>浮动元素；</li><li>绝对定位元素；</li><li>非块级但仍能包含块级元素的容器（如 inline-blocks, table-cells, table-captions）；</li><li>块级的能包含块级元素的容器，且属性 overflow 不为 visible。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;p&gt;CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified ru</summary>
      
    
    
    
    <category term="css" scheme="https://hustchenshu.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://hustchenshu.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识</title>
    <link href="https://hustchenshu.github.io/2021/07/17/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://hustchenshu.github.io/2021/07/17/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#javascript">JavaScript</a><ul><li><a href="#%E6%96%87%E6%B3%95">文法</a></li><li><a href="#%E8%AF%AD%E4%B9%89">语义</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6">运行时</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B">类型</a></li></ul></li><li><a href="#%E7%AE%97%E6%B3%95"><strong>算法</strong></a></li><li><a href="#%E5%AD%A6%E4%B9%A0%E6%96%87%E7%8C%AE">学习文献</a></li></ul></li></ul></li></ul><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p><img src="https://static001.geekbang.org/resource/image/6a/9b/6aec0a09381a2f74014ec604ef99c19b.png" alt="javascript"></p><p>编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。</p><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>7种语言类型</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Symbol</li><li>Object</li></ul><p><strong>undefined 和 null</strong></p><p>Undefined 跟 Null 有一定的表意差别，Null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</p><p><strong>特殊情况</strong></p><ul><li>null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</li><li>String 有最大长度是 2^53 - 1</li><li>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64 - 2^53+3) 个值。<ul><li>例外情况1：Infinity，无穷大；</li><li>例外情况2：-Infinity，负无穷大。</li><li>例外情况3：NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；</li></ul></li></ul><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/double-bit.png" alt="double-bit"></p><ul><li>Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</li><li>Number.MIN_SAFE_INTEGER === 1 - Math.pow(2, 53)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三种例外情况：</span><br><span class="line">无穷大： 符号位为0，指数位（阶码位）全为1,小数位全为0；（1种情况）</span><br><span class="line">0111 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">负无穷大： 符号位为1，指数位（阶码位）全为1,小数位全为0；（1种情况）</span><br><span class="line">1111 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">NaN: 符号位为0或者1，指数位（阶码位）全为1,小数位非全0；（2 * （2^52 - 1）种情况）</span><br><span class="line">S111 1111 1111 XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX</span><br><span class="line"></span><br><span class="line">所以最终Number的可取值为： 2^64 - 2^53 + 3</span><br><span class="line">2^64： 总取值</span><br><span class="line">2^53： 指数位（阶码位）全为1的情况</span><br><span class="line">3：    指数位（阶码位）全为1总结为3个有效值；</span><br><span class="line"></span><br><span class="line">或者这样算：</span><br><span class="line">2^64 - （2 * （2^52 - 1） + 3</span><br></pre></td></tr></table></figure><ul><li><p>区分 +0 和 -0 的方式，检测 1/x 是 Infinity 还是 -Infinity。</p></li><li><p>Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。</p></li><li><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON);</span><br></pre></td></tr></table></figure></li><li><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。\</p></li><li><p>可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">o[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">value</span>: v++, done: v &gt; <span class="number">10</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> o) </span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 0 1 2 3 ... 9</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</li><li>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</li><li>parseInt把字符串转为证书，遇到非数字时停止解析，第一个字符为零，则基于八进制求值；Number遇到非数字返回NaN；</li></ul><p><strong>Object</strong><br>对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><p><strong>类型转换</strong><br><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/double-equal.jpg" alt="transfer"></p><p><strong>装箱转换</strong></p><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p><p>Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><p><strong>拆箱转换</strong></p><p>ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。<br>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h3><h3 id="学习文献"><a href="#学习文献" class="headerlink" title="学习文献"></a>学习文献</h3><p><a href="https://www.boatsky.com/blog/26">双精度浮点64位类型IEEE754标准</a><br><a href="https://www.cnblogs.com/fsjohnhuang/p/5115672.html">0.1 + 0.2 === 0.3问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#javascript&quot;&gt;JavaScript&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%87%E6%B3%95&quot;&gt;文法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%AD%E4%B9%89&quot;&gt;语义&lt;/a&gt;&lt;/li</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS当中的对象</title>
    <link href="https://hustchenshu.github.io/2021/07/17/object/"/>
    <id>https://hustchenshu.github.io/2021/07/17/object/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ul><li><a href="#object">Object</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81">对象的特征</a></li><li><a href="#javascript%E4%B8%AD%E5%AF%B9%E8%B1%A1">JavaScript中对象</a><ul><li><a href="#%E7%8B%AC%E6%9C%89%E7%9A%84%E7%89%B9%E8%89%B2">独有的特色</a></li><li><a href="#%E4%B8%A4%E7%B1%BB%E5%B1%9E%E6%80%A7">两类属性</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7">数据属性</a></li><li><a href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7">访问器属性</a></li></ul></li></ul></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1">面向对象还是基于对象</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1">如何定义面向对象和基于对象</a></li></ul></li><li><a href="#%E5%8E%9F%E5%9E%8B">原型</a><ul><li><a href="#%E5%8E%9F%E5%9E%8B%E7%B3%BB%E7%BB%9F">原型系统</a></li><li><a href="#%E7%B1%BB%E4%B8%8E%E5%8E%9F%E5%9E%8B">类与原型</a><ul><li><a href="#new">new</a></li></ul></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB">对象分类</a><ul><li><a href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1">内置对象·原生对象</a></li></ul></li></ul></li></ul><h2 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h2><ul><li><p>对象具有唯一标识性：及时完全相同的两个对象，也并非是同一个对象;（内存地址）</p></li><li><p>对象有状态：独享具有状态，同意对象可能处于不用状态之下;</p></li><li><p>对象具有行为：即对象的状态，可能因为他的行为产生变迁；</p></li></ul><h2 id="JavaScript中对象"><a href="#JavaScript中对象" class="headerlink" title="JavaScript中对象"></a>JavaScript中对象</h2><h3 id="独有的特色"><a href="#独有的特色" class="headerlink" title="独有的特色"></a>独有的特色</h3><p>JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p><p><code>人话：</code>不一定要在声明时确定对象的属性，可以动态添加；</p><h3 id="两类属性"><a href="#两类属性" class="headerlink" title="两类属性"></a>两类属性</h3><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul><li>value：就是属性的值。</li><li>writable：决定属性能否被赋值。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><ul><li>getter：函数或 undefined，在取属性值时被调用。</li><li>setter：函数或 undefined，在设置属性值时被调用。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><h2 id="面向对象还是基于对象"><a href="#面向对象还是基于对象" class="headerlink" title="面向对象还是基于对象"></a>面向对象还是基于对象</h2><p><code>“JavaScript 不是面向对象”？</code></p><p>因为实际上 JavaScript 对象的运行时是一个“属性的集合”，由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。<br>可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式，所以它也是正统的面向对象语言。</p><p><code>基于对象？基于类？</code></p><p>在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。</p><p>“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。</p><p>还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。</p><h3 id="如何定义面向对象和基于对象"><a href="#如何定义面向对象和基于对象" class="headerlink" title="如何定义面向对象和基于对象"></a>如何定义面向对象和基于对象</h3><ul><li>基于对象</li></ul><p>语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合</p><ul><li>面向对象</li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型系统"><a href="#原型系统" class="headerlink" title="原型系统"></a>原型系统</h3><p>原型系统满足两条规则</p><ul><li>如果所有对象都有私有字段[[prototype]]，就是对象的原型</li><li>读一个属性，如果过对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止；</li></ul><h3 id="类与原型"><a href="#类与原型" class="headerlink" title="类与原型"></a>类与原型</h3><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了[[class]]属性，以表示它们的类。语言使用者唯一可以访问[[class]]属性的方式是 Object.prototype.toString。</p><p><code>在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，可被覆盖</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;MyObject&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o + <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>es6 加入了新类型class</code></p><p>ES6 中引入了 class 关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施。</p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>new运算符实际操作：</p><ul><li>以构造器的prototype属性为原型，创建新对象；</li><li>将this和调用参数传递给构造器，执行；</li><li>如果构造器返回对象，则返回，否则返回第一步创建的对象；</li></ul><p>所以可以这样模拟类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.p1 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.p2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> c1;</span><br><span class="line">o1.p2();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">c2.prototype.p1 = <span class="number">1</span>;</span><br><span class="line">c2.prototype.p2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> c2;</span><br><span class="line">o2.p2();</span><br></pre></td></tr></table></figure><h2 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h2><ul><li>宿主对象：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li><li>内置对象：由 JavaScript 语言提供的对象。<ul><li>固有对象：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li><li>原生对象：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li><li>普通对象：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li></ul></li></ul><h3 id="内置对象·原生对象"><a href="#内置对象·原生对象" class="headerlink" title="内置对象·原生对象"></a>内置对象·原生对象</h3><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/native-objects.png" alt="native-objects"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#object&quot;&gt;Object&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue vs react</title>
    <link href="https://hustchenshu.github.io/2021/07/17/vue%20vs%20react/"/>
    <id>https://hustchenshu.github.io/2021/07/17/vue%20vs%20react/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-vs-react"><a href="#vue-vs-react" class="headerlink" title="vue vs react"></a>vue vs react</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><table><thead><tr><th>对比项</th><th>vue2</th><th>vue3</th><th>react15</th><th>react16.8+</th></tr></thead><tbody><tr><td>api</td><td>options</td><td>composition</td><td>class</td><td>hooks</td></tr></tbody></table><h3 id="option优缺点"><a href="#option优缺点" class="headerlink" title="option优缺点"></a>option优缺点</h3><ul><li><p>优点</p><ul><li>便于理解</li><li>数据方法划分明显</li></ul></li><li><p>缺点</p><ul><li>可维护性差，反复横跳</li><li>可扩展性差，mixins有命名冲突问题，且以黑盒方式引入，不利于类型推断；</li></ul></li></ul><h3 id="composition优缺点"><a href="#composition优缺点" class="headerlink" title="composition优缺点"></a>composition优缺点</h3><ul><li>优点<ul><li>功能分块，避免反复横跳</li><li>对vue可以进行tree shaking</li><li>方便组合，组合优于继承</li><li>数据流清晰（定义、更新）</li><li>render函数只执行一次，后续靠的是响应式通知</li></ul></li></ul><ul><li>缺点<ul><li>难看，较难理解</li></ul></li></ul><h3 id="hooks优缺点"><a href="#hooks优缺点" class="headerlink" title="hooks优缺点"></a>hooks优缺点</h3><ul><li>优点</li></ul><ul><li>缺点<ul><li>render函数每次都会执行，hooks有顺序限制</li></ul></li></ul><h2 id="数据流（mutable-vs-immutable）"><a href="#数据流（mutable-vs-immutable）" class="headerlink" title="数据流（mutable vs immutable）"></a>数据流（mutable vs immutable）</h2><p><strong>双向数据流</strong><br>代表：vue<br>可变数据，依赖收集，主动通知来驱动模板</p><p><strong>单向数据流</strong><br>代表：react<br>数据不可变，计算数据diff来驱动模板</p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><p>jsx就是纯js，在react当中会被解析成<code>React.createElement</code></p><ul><li>优点<ul><li>十分自由，js支持的jsx都支持</li></ul></li></ul><ul><li>缺点<ul><li>动态性强，可优化性弱（是我给你自由过了火）;</li></ul></li></ul><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>特定语法，解析成<code>creatVNode</code>,变异过程当中会区分动态、静态节点，纯静态节点会跳过diff</p><ul><li>优点<ul><li>有限制，可遍历，可优化性强</li><li>形式上更接近html，符合认知</li></ul></li><li>缺点<ul><li>不够动态，自由度小，有语法限制（仅能使用限定api）</li></ul></li></ul><h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><h2 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h2><p>使用js对象的形式来描述dom结构</p><ul><li>响应式：数据变更了通知订阅者，主动通知</li><li>vdom：不知道数据哪里变了，通过生成新vdom与旧的vdom进行diff才知道变化，被动计算;</li></ul><h3 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h3><ul><li>性能跟模板大小正相关，跟动态节点数量无关；</li><li></li></ul><h3 id="vue-vdom-响应式"><a href="#vue-vdom-响应式" class="headerlink" title="vue = vdom + 响应式"></a>vue = vdom + 响应式</h3><p>vue1只有响应式，一旦响应式对象太多，导致卡顿；<br>vue2引入了vdom，使用的是snabbdom的代码，双端预判，较少循环次数；<br>vue3在vue2静态标记的基础上，动态标签内部的静态标签，使用block来标记；</p><p><strong>vue怎么区分使用vdom还是使用响应式呢？</strong><br>根据组件划分，组件之间通过响应式通知，组件内部，通过vdom计算diff；</p><p>fiber也就是说所谓的时间切片；<br>1、任务可以切开，利用空闲时间计算；<br>2、diff可以中断</p><p>原理，把树形结构转化成链表结构</p><h3 id="react-纯vdom"><a href="#react-纯vdom" class="headerlink" title="react 纯vdom"></a>react 纯vdom</h3><p>解析jsx，生成createElement，没有太多标记，所以能做的优化很少</p><p><strong>vdom杀手锏：</strong></p><ul><li>性能优化；</li><li>跨端；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-vs-react&quot;&gt;&lt;a href=&quot;#vue-vs-react&quot; class=&quot;headerlink&quot; title=&quot;vue vs react&quot;&gt;&lt;/a&gt;vue vs react&lt;/h1&gt;&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;</summary>
      
    
    
    
    <category term="前端框架" scheme="https://hustchenshu.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="https://hustchenshu.github.io/tags/vue/"/>
    
    <category term="react" scheme="https://hustchenshu.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（Dynamic Programming）</title>
    <link href="https://hustchenshu.github.io/2021/07/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://hustchenshu.github.io/2021/07/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dynamic-programming">动态规划（Dynamic Programming）</a><ul><li><a href="#dp%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">DP算法设计</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B">常见题型</a><ul><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97longest-common-sequence">最长公共子序列（longest common sequence）</a><ul><li><a href="#%E5%88%86%E6%9E%90">分析</a></li></ul></li><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2longest-common-substring">最长公共子串（longest common substring）</a></li><li><a href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97longest-increase-sequence">最长递增子序列（longest increase sequence）</a><ul><li><a href="#%E5%88%86%E6%9E%90-1">分析</a></li></ul></li><li><a href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">背包问题</a><ul><li><a href="#01%E9%97%AE%E9%A2%98">0/1问题</a></li><li><a href="#%E6%9C%89%E7%95%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">有界背包问题</a></li><li><a href="#%E6%97%A0%E7%95%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">无界背包问题</a></li></ul></li><li><a href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98">最大子数列问题</a></li></ul></li><li><a href="#reference">reference</a></li></ul></li></ul><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。<br>动态规划就是把主问题的所有子问题穷尽求出最优解。</p><h2 id="DP算法设计"><a href="#DP算法设计" class="headerlink" title="DP算法设计"></a>DP算法设计</h2><ul><li>首先，把当前问题的状态设为x；对于状态x，f(x)为最优解；</li><li>找出f(x)与那些状态有关，并写出其他们之间的关联（状态转移方程）</li><li></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="最长公共子序列（longest-common-sequence）"><a href="#最长公共子序列（longest-common-sequence）" class="headerlink" title="最长公共子序列（longest common sequence）"></a>最长公共子序列（longest common sequence）</h3><p>最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>设定：</li></ul><p>c[i,j]为系列X,Y的最长公共子序列</p><ul><li>状态转移方程:</li></ul><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/lcs-an.png" alt="lcs"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLCS</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length1 = str1.length;</span><br><span class="line">    <span class="keyword">const</span> length2 = str2.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结果表</span></span><br><span class="line">    <span class="keyword">const</span> result_arr =  <span class="keyword">new</span> <span class="built_in">Array</span>(length1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= length1;i++) &#123;</span><br><span class="line">        result_arr[i] = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">            result_arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; length1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j &lt; length2 + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> y = str2.charAt(j - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(&#123;</span><br><span class="line">                i,j,</span><br><span class="line">                x,y</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(x === y) &#123;</span><br><span class="line">                result_arr[i][j] = result_arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result_arr[i][j] = <span class="built_in">Math</span>.max(result_arr[i - <span class="number">1</span>][j],result_arr[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`i=<span class="subst">$&#123;i&#125;</span>;j=<span class="subst">$&#123;j&#125;</span>; =&gt; <span class="subst">$&#123;result_arr[i][j]&#125;</span>`</span>)</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result_arr[length1 - <span class="number">1</span>][length2 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子串（longest-common-substring）"><a href="#最长公共子串（longest-common-substring）" class="headerlink" title="最长公共子串（longest common substring）"></a>最长公共子串（longest common substring）</h3><ul><li>设定：</li></ul><p>c[i,j]为字符串X和字符串Y的最长公共子串</p><ul><li>状态转移方程:</li></ul><p>当 xi === yi 时，c[i,j] = c[i-1,j-1] + 1;<br>否则c[i,j] = c[i-1,j-1]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLCS</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length1 = str1.length;</span><br><span class="line">    <span class="keyword">const</span> length2 = str2.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结果表</span></span><br><span class="line">    <span class="keyword">const</span> result_arr =  <span class="keyword">new</span> <span class="built_in">Array</span>(length1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= length1;i++) &#123;</span><br><span class="line">        result_arr[i] = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">            result_arr[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; length1 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j &lt; length2 + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> y = str2.charAt(j - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(&#123;</span><br><span class="line">                i,j,</span><br><span class="line">                x,y</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(x === y) &#123;</span><br><span class="line">                result_arr[i][j] = result_arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(result_arr[i][j] &gt; maxLength) &#123;</span><br><span class="line">                    maxLength = result_arr[i][j];</span><br><span class="line">                    end = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不连续了，置为0</span></span><br><span class="line">                result_arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`i=<span class="subst">$&#123;i&#125;</span>;j=<span class="subst">$&#123;j&#125;</span>; =&gt; <span class="subst">$&#123;result_arr[i][j]&#125;</span>`</span>)</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.slice(end - maxLength, maxLength)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列（longest-increase-sequence）"><a href="#最长递增子序列（longest-increase-sequence）" class="headerlink" title="最长递增子序列（longest increase sequence）"></a>最长递增子序列（longest increase sequence）</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul><li>设定：</li></ul><p>c[i]为字符串X.slice(0,i)的最长递增子序列,f(i)为c[i]的数组长度；</p><p>则当x[i] &gt; max(c[i-1])时，c[i] = […c[i-1], x[i]];<br>否则c[i] = c[i-1];</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLIS</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    temp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        temp[i] = temp[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">const</span> isBigest = !arr.slice(<span class="number">0</span>,i).some(<span class="function"><span class="params">p</span> =&gt;</span> p &gt; arr[i]);</span><br><span class="line">        <span class="built_in">console</span>.log(&#123;</span><br><span class="line">            <span class="string">&#x27;arr[i-1]&#x27;</span>: arr.slice(<span class="number">0</span>,i),</span><br><span class="line">            <span class="string">&#x27;arr[i]&#x27;</span>: arr[i],</span><br><span class="line">            isBigest</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(isBigest)&#123;</span><br><span class="line">            temp[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="0-1问题"><a href="#0-1问题" class="headerlink" title="0/1问题"></a>0/1问题</h4><p><code>现有n件物品和一个容量为c的背包。第i件物品的重量是重量为w[i]，价值是v[i]。已知对于一件物品必须选择取（用1表示）或者不取（用0表示），且每件物品只能被取一次（这就是“0-1”的含义）。求放置哪些物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。</code></p><h4 id="有界背包问题"><a href="#有界背包问题" class="headerlink" title="有界背包问题"></a>有界背包问题</h4><p><code>现有n种物品和一个容量为c的背包。第i件物品的重量是重量为w[i]，价值是v[i]。已知对于一件物品可选数量为（0~c）。求怎样选择物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。</code></p><h4 id="无界背包问题"><a href="#无界背包问题" class="headerlink" title="无界背包问题"></a>无界背包问题</h4><p><code>现有n种物品和一个容量为c的背包。第i件物品的重量是重量为w[i]，价值是v[i]。求怎样选择物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。</code></p><h3 id="最大子数列问题"><a href="#最大子数列问题" class="headerlink" title="最大子数列问题"></a>最大子数列问题</h3><p>对于数列L，找出L的的子序列，使得：</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/largestSubArray.svg" alt="lagresetSubArr"></p><p>如对于数列<code>L = [-2,-3,4,-1,-2,1,5,-3]</code>,其最大子数列为：<code>[4,-1,-2,1,5]</code>,此时<code>M = 4 + (-1) + (-2) + 1 + 5 = 7</code>;</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/largerSubArr-example.png" alt="example"></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://www.zhihu.com/question/23995189">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dynamic-programming&quot;&gt;动态规划（</summary>
      
    
    
    
    <category term="算法" scheme="https://hustchenshu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
    <category term="算法" scheme="https://hustchenshu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>事件循环，宏任务与微任务</title>
    <link href="https://hustchenshu.github.io/2021/07/17/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    <id>https://hustchenshu.github.io/2021/07/17/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><pre><code>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏任务与微任务一直都是面试常见题型，很多时候不仔细分析可能啪叽一下就掉坑了。虽然说实际上那代码一跑就知道啥顺序，但是异步执行的分析咱还是躲不过。</span><br></pre></td></tr></table></figure><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p><p>具体有哪些呢：</p><ul><li>宏任务<ul><li>script(整体代码)</li><li>setTimeout</li><li>setInterval</li><li>I/O</li><li>UI交互</li><li>postMessage</li><li>MessageChannel</li><li>setImmediate</li><li>……</li></ul></li><li>微任务<ul><li>Promise.then</li><li>Object.Observe</li><li>MutaionObserver</li><li>process.nextTick</li><li>……</li></ul></li></ul><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务运行机制大致如下：</p><ul><li>1.执行一个宏任务；</li><li>2.若执行过程中遇到微任务，添加到微任务队列中；</li><li>3.宏任务执行完毕，检查并执行当前微任务当中所有任务（依次）；</li><li>4.进入下一个宏任务，回到第一步；</li></ul><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/micro_macro_pic.png" alt="pic"></p><h2 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h2><p>之前学习winter老师的重学前端课程的时候，winter老师在互动区对一道题做了分析解答，这里借鉴一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sync1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeoutPromise&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;pro_then&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;pro_timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;last_setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sync2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>安装运行机制，我们分析如下，这个代码段就是一个宏任务，所以从第一句到最后一局这个代码段是我们的第一个宏任务，我们开始分析如下：</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/micro_macro_1.png" alt="step-1"></p><p>第一个宏任务运行下来，总共执行了3次setTimeout，产生了3个宏任务，同时调用了一个Promise.resolve函数，产生了一个微任务，如上图；所以第一次宏任务之后，打印顺序为：<br>sync1、promise、sync2，这时，setTimeout1，setTimeoutPromise，last_setTimeout 在宏任务队列中，pro_then 在微任务队列中。</p><p>运行完<code>console.log(&#39;sync2&#39;)</code>之后，第一个宏任务执行完毕，我们检查此时的微任务队列非空，因此执行微任务队列当中的函数，即下图当中的步骤4，即打印出<code>pro_then</code>，然后又调用setTimeout，因此宏任务队列又加入一员。</p><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/micro_macro_2.png" alt="step-1"></p><p>微任务队列执行完，重新从宏任务队列中获取宏任务，因此依次执行5、6、7、8这几个代码，依次打印setTimeout1，setTimeoutPromise，last_setTimeout，pro_timeout。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://segmentfault.com/a/1190000020225668">js中的宏任务与微任务</a>;</li><li><a href="https://time.geekbang.org/column/article/88275">重学前端-期中答疑</a>;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
    <category term="异步" scheme="https://hustchenshu.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="微任务" scheme="https://hustchenshu.github.io/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="宏任务" scheme="https://hustchenshu.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://hustchenshu.github.io/2021/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://hustchenshu.github.io/2021/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-17T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在计算机科学中, 一个 链表 是数据元素的线性集合, 元素的线性顺序不是由它们在内存中的物理位置给出的。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainNode</span> </span>&#123;</span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chainHeader = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> ChainNode(i);</span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">0</span>) &#123;</span><br><span class="line">        chainHeader = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>插入</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部插入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertIntoTail</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = chainHeader;</span><br><span class="line">    <span class="keyword">const</span> insertVal = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span>(target.next) &#123;</span><br><span class="line">        target = target.next;</span><br><span class="line">    &#125;</span><br><span class="line">    target.next = <span class="keyword">new</span> ChainNode(insertVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>搜索</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">header , value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = header;</span><br><span class="line">    <span class="keyword">while</span>(start) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start.value === value) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;;</span><br><span class="line">        start = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delByValue</span>(<span class="params">header, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = header;</span><br><span class="line">    <span class="keyword">if</span>(current) &#123;</span><br><span class="line">        <span class="keyword">if</span>(current.value === value) &#123;</span><br><span class="line">            current = delByValue(current.next, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.next = delByValue(current.next, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">header</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(header);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> start = header; start; start = start.next)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(start.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反向遍历</li><li></li></ul><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;在计算机科学中, 一个</summary>
      
    
    
    
    <category term="算法" scheme="https://hustchenshu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
    <category term="算法" scheme="https://hustchenshu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js手写系列</title>
    <link href="https://hustchenshu.github.io/2021/07/17/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/"/>
    <id>https://hustchenshu.github.io/2021/07/17/js%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/</id>
    <published>2021-07-17T13:43:07.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PROMISE_STATUS = &#123;</span><br><span class="line">    <span class="attr">FUIFILLED</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">    <span class="attr">REJECTED</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">    <span class="attr">PENDING</span>: <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    private status = PROMISE_STATUS.PENDING;</span><br><span class="line">    resolveCallbacks = [];</span><br><span class="line">    rejectCallbacks = [];</span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    error = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === PROMISE_STATUS.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = PROMISE_STATUS.FUIFILLED;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>.resolveCallbacks.length) &#123;</span><br><span class="line">                <span class="built_in">this</span>.resolveCallbacks.shift()(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === PROMISE_STATUS.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = PROMISE_STATUS.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.error = error;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>.rejectCallbacks.length) &#123;</span><br><span class="line">                <span class="built_in">this</span>.rejectCallbacks.shift()(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">swith</span>(<span class="params"><span class="built_in">this</span>.status</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> PROMISE_STATUS.PENDING:</span><br><span class="line">                onFulfilled &amp;&amp; <span class="built_in">this</span>.resolveCallbacks.push(onFulfilled);</span><br><span class="line">                onRejected &amp;&amp; <span class="built_in">this</span>.rejectCallbacks.push(onRejected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROMISE_STATUS.FUIFILLED:</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROMISE_STATUS.REJECTED:</span><br><span class="line">                onRejected(<span class="built_in">this</span>.error);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建空对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 2. 链接原型链</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title">constructor</span> = [].<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">    obj.__proto__ = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line">    <span class="comment">// 3. 绑定this值</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">obj, <span class="built_in">arguments</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = age || <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.bark = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;www, i am&#x27;</span>, <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello:&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jack = createNew(dog, <span class="string">&#x27;mardin&#x27;</span>, <span class="number">22</span>);</span><br><span class="line">jack.bark();</span><br><span class="line">jack.hello();</span><br><span class="line"><span class="built_in">console</span>.log(jack.__proto__ === dog.prototype)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply/call/bind"></a>apply/call/bind</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="批量请求"><a href="#批量请求" class="headerlink" title="批量请求"></a>批量请求</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;节流&quot;&gt;&lt;a href=&quot;#节流&quot; class=&quot;headerlink&quot; title=&quot;节流&quot;&gt;&lt;/a&gt;节流&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vite2.0</title>
    <link href="https://hustchenshu.github.io/2021/06/17/vite/"/>
    <id>https://hustchenshu.github.io/2021/06/17/vite/</id>
    <published>2021-06-17T11:55:53.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="插件机制和API"><a href="#插件机制和API" class="headerlink" title="插件机制和API"></a>插件机制和API</h3><h3 id="多框架支持"><a href="#多框架支持" class="headerlink" title="多框架支持"></a>多框架支持</h3><ul><li>Vue 3 单文件组件支持：@vitejs/plugin-vue</li><li>Vue 3 JSX 支持：@vitejs/plugin-vue-jsx</li><li>Vue 2 支持：underfin/vite-plugin-vue2</li></ul><h3 id="基于esbuild的依赖预打包"><a href="#基于esbuild的依赖预打包" class="headerlink" title="基于esbuild的依赖预打包"></a>基于esbuild的依赖预打包</h3><ul><li>原因</li></ul><p>Vite 以 原生 ESM 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。如下是浏览器支持的导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>如下的裸模块导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>&#39;b&#39;</code> 这个esm模块在浏览器中是无法获取到的，这个包可能是node_modules当中的依赖，而且<code>b</code>模块可能是commomjs/UMD模块，所以首先我们需要将其转化为ESM格式，而且需要将这个导入语法重写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;/node_modules/.vite/b.js&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>优势</p><ul><li>预先转化成esm，可利用esm模块的所有优势；</li><li>一次转化，终身适用，仅在依赖变更的时候触发重建；</li><li>采用强缓存，减少不必要请求（一般情况下依赖包不会变动）</li><li>开箱支持ts，预编译阶段将ts编译成js，且速度是<code>tsc</code>的<code>20~30</code>倍开箱即用</li></ul></li><li><p>不足</p><ul><li>功能不够完善，特别是代码分割和 CSS 处理方面；</li><li>对ts只执行转移，不含类型信息，丢失类型推到；</li></ul></li></ul><h3 id="更好的css支持"><a href="#更好的css支持" class="headerlink" title="更好的css支持"></a>更好的css支持</h3><ul><li>CSS Modules</li></ul><p>导入 .css 文件将会把内容插入到 <style> 标签中，同时也带有 HMR 支持。<br>任何以 .module.css 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example.module.css */</span></span><br><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./example.module.css&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).className = classes.red</span><br></pre></td></tr></table></figure><ul><li>CSS 预处理器</li></ul><p>Vite 也提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持,只需要安装特定的预处理器依赖本身即可获得支持；</p><h3 id="ssr支持"><a href="#ssr支持" class="headerlink" title="ssr支持"></a>ssr支持</h3><h3 id="旧浏览器支持"><a href="#旧浏览器支持" class="headerlink" title="旧浏览器支持"></a>旧浏览器支持</h3><p>Vite 默认只支持原生支持 ESM 的现代浏览器，但可以通过官方的 @vitejs/plugin-legacy 来支持旧浏览器。legacy 插件会自动额外生成一个针对旧浏览器的包，并且在 html 中插入根据浏览器 ESM 支持来选择性加载对应包的代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新特性&quot;&gt;&lt;a href=&quot;#新特性&quot; class=&quot;headerlink&quot; title=&quot;新特性&quot;&gt;&lt;/a&gt;新特性&lt;/h2&gt;&lt;h3 id=&quot;插件机制和API&quot;&gt;&lt;a href=&quot;#插件机制和API&quot; class=&quot;headerlink&quot; title=&quot;插件机制和</summary>
      
    
    
    
    <category term="前端框架" scheme="https://hustchenshu.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="vue" scheme="https://hustchenshu.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/"/>
    
    
    <category term="vue" scheme="https://hustchenshu.github.io/tags/vue/"/>
    
    <category term="vite" scheme="https://hustchenshu.github.io/tags/vite/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://hustchenshu.github.io/2021/06/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"/>
    <id>https://hustchenshu.github.io/2021/06/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/</id>
    <published>2021-06-12T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><code>有一个文本串S，和一个模式串P，现在要查找P在S中的位置</code></p><ul><li>暴力破解</li></ul><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p><ul><li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li><li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSubStr</span>(<span class="params">str, patter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str_len = str.length;</span><br><span class="line">    <span class="keyword">const</span> patter_len = patter.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str_len &amp;&amp; j &lt; patter_len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] === patter[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j === patter_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kmp</li></ul><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/kmp.gif" alt="kmp"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSubStr</span>(<span class="params">str, patter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str_len = str.length;</span><br><span class="line">    <span class="keyword">const</span> patter_len = patter.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str_len &amp;&amp; j &lt; patter_len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] === patter[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j === patter_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">patter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = [];</span><br><span class="line">    <span class="keyword">const</span> length = patter.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(patter.slice(<span class="number">0</span>,index));</span><br><span class="line">        <span class="keyword">while</span>(index &lt; i &amp;&amp; patter[index] === patter[i-index])&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;index&#125;</span>:<span class="subst">$&#123;patter[index]&#125;</span>;<span class="subst">$&#123;i-index&#125;</span>:<span class="subst">$&#123;patter[i-index]&#125;</span>;`</span>)</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i++] = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.sohu.com/a/336648975_453160">史上最简(详细)KMP算法讲解，看不懂算我输！ </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;有一个文本串S，和一个模式串P，现在要查找P在S中的位置&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暴力破解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设现在</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
    <category term="算法" scheme="https://hustchenshu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://hustchenshu.github.io/2021/05/07/HTTP/"/>
    <id>https://hustchenshu.github.io/2021/05/07/HTTP/</id>
    <published>2021-05-07T14:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/http-proto.jpg" alt="http-proto"></p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><table><thead><tr><th>method</th><th>场景</th><th>异同</th><th>备注</th></tr></thead><tbody><tr><td>GET</td><td>地址栏访问</br>ajax请求</td><td></td><td></td></tr><tr><td>POST</td><td>ajax请求</br>表单提交</td><td></td><td></td></tr><tr><td>HEAD</td><td>由js发起</td><td>与get类似，但只返回响应头</td><td></td></tr><tr><td>PUT</td><td>添加资源</td><td></td><td></td></tr><tr><td>DELETE</td><td>删除资源</td><td></td><td></td></tr><tr><td>CONNECT</td><td>用于https/websocket</td><td></td><td></td></tr><tr><td>OPTIONS</td><td>用于调试</td><td></td><td></td></tr><tr><td>TRACE</td><td>用于调试</td><td></td><td></td></tr></tbody></table><h3 id="status-and-text"><a href="#status-and-text" class="headerlink" title="status and text"></a>status and text</h3><table><thead><tr><th>status</th><th>意义</th><th>备注</th></tr></thead><tbody><tr><td>1xx</td><td></td><td></td></tr><tr><td>200</td><td>网页请求成功</td><td></td></tr><tr><td>301</td><td></td><td></td></tr><tr><td>302</td><td></td><td></td></tr><tr><td>304</td><td></td><td></td></tr><tr><td>403</td><td></td><td></td></tr><tr><td>404</td><td></td><td></td></tr><tr><td>418</td><td></td><td></td></tr><tr><td>500</td><td></td><td></td></tr><tr><td>503</td><td></td><td></td></tr></tbody></table><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><strong>request header</strong></p><table><thead><tr><th>request header</th><th>规定</th></tr></thead><tbody><tr><td>accept</td><td></td></tr><tr><td>accept-encoding</td><td></td></tr><tr><td>accept-language</td><td></td></tr><tr><td>cache-control</td><td></td></tr><tr><td>connection</td><td></td></tr><tr><td>host</td><td></td></tr><tr><td>if-modified-since</td><td></td></tr><tr><td>if-none-match</td><td></td></tr><tr><td>user-agent</td><td></td></tr><tr><td>cookie</td><td></td></tr></tbody></table><p><strong>response header</strong></p><table><thead><tr><th>response header</th><th>规定</th></tr></thead><tbody><tr><td>cache-control</td><td></td></tr><tr><td>connection</td><td></td></tr><tr><td>content-type</td><td></td></tr><tr><td>content-length</td><td></td></tr><tr><td>content-language</td><td></td></tr><tr><td>date</td><td></td></tr><tr><td>etag</td><td></td></tr><tr><td>expires</td><td></td></tr><tr><td>keep-alive</td><td></td></tr><tr><td>last-modified</td><td></td></tr><tr><td>server</td><td></td></tr><tr><td>set-cookie</td><td></td></tr><tr><td>via</td><td></td></tr></tbody></table><p><strong>Request Body</strong></p><ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/xml</li></ul><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><ul><li><p>长连接</p><p>  默认开启长链接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</p></li><li><p>宽带和网络连接优化</p><p>  支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器</p></li><li><p>缓存策略</p><p>  在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>错误状态响应码</p><p>  新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p>Host头处理</p><p>  http1.0中默认每台服务器都绑定唯一的一个IP地址,所以请求消息中url并没有传递主机名,也就是hostname.<br>  http1.1中请求消息和响应消息都支持Host头域,而且,如果我们不传这个字段还会报一个400(bad request)的状态码</p></li></ul><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a><a href="https://tools.ietf.org/html/rfc7540">HTTP 2</a></h2><ul><li>多路复用  HTTP/2 中每个请求都被拆分成多个 Frame 通过一条 TCP 连接同时被传输，这样即使一个请求被阻塞，也不会影响其他的请求。同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li></ul><ul><li><p>服务器推送</p><p>  允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p></li><li><p>头部压缩</p><p>  HTTP1.X时代，状态行和头部却没有经过任何压缩，直接以纯文本传输，导致消耗在头部的流量越来越多。HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p></li><li><p>二进制流</p><p>  将传输信息分割为跟小的信息帧，并对她们进行二进制编码。常见的有header帧、其会开启一个新的流，之后是Data帧，传输正文实体，多个Data帧属于一个流。</p></li></ul><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a><a href="https://zhuanlan.zhihu.com/p/143464334">HTTP 3</a></h2><p>QUIC 是用来替代 TCP、SSL/TLS 的传输层协议，在传输层之上还有应用层，我们熟知的应用层协议有 HTTP、FTP、IMAP 等，这些协议理论上都可以运行在 QUIC 之上，其中运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3，这就是”HTTP over QUIC 即 HTTP/3“的含义。</p><ul><li><p>零RRT建立链接</p><p>  DH 密钥交换算法，DH 算法的核心就是服务端生成 a、g、p 3 个随机数，a 自己持有，g 和 p 要传输给客户端，而客户端会生成 b 这 1 个随机数，通过 DH 算法客户端和服务端可以算出同样的密钥。在这过程中 a 和 b 并不参与网络传输，安全性大大提高。因为 p 和 g 是大数，所以即使在网络中传输的 p、g、A、B 都被劫持，那么靠现在的计算机算力也没法破解密钥。</p><p>  QUIC 从请求连接到正式接发 HTTP 数据一共花了 1 RTT，这 1 个 RTT 主要是为了获取 Server Config，后面的连接如果客户端缓存了 Server Config，那么就可以直接发送 HTTP 数据，实现 0 RTT 建立连接。</p></li><li><p>连接迁移</p><p>  TCP 连接基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化。</p><p>  QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。</p></li><li><p>队头阻塞/多路复用</p><p>  HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking）：一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽资源。</p><p>  HTTP/2 的每个请求都会被拆分成多个 Frame，不同请求的 Frame 组合成 Stream，Stream 是 TCP 上的逻辑传输单元，在一条 TCP 连接上同时发送 4 个 Stream，其中 Stream1 已正确送达，Stream2 中的第 3 个 Frame 丢失，TCP 处理数据时有严格的前后顺序，先发送的 Frame 要先被处理，这样就会要求发送方重新发送第 3 个 Frame，Stream3 和 Stream4 虽然已到达但却不能被处理，那么这时整条连接都被阻塞。</p><p>  QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题；<br>  QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a><a href="https://tools.ietf.org/html/rfc2818">HTTPS</a></h2><p>HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。</p><ul><li><p>保密性–对称加密、非对称加密</p><p>  我们说http是明文传输，所以https首要解决的问题就是它的通信加密，达到保密性。首先客户端请求服务端，服务端将自己的公钥返回，客户端拿到公钥后就可以用它来加密要传输的数据data ，将加密数据secret data发送到服务端后通过服务端的私钥来解密，以此完成加密传输。</p><p>  有了非对称加密，只要我们将其中的data换成随机码key，这个key作为对称加密中密钥。密钥传输问题就解决了，同时很好地利用了对称加密的高效率。</p></li><li><p>真实性、准确性–数字证书、签名</p><p>所谓证书就是第三方（自签证书没有公证效应）颁发的认证，在HTTPS中存在一种认证机构即CA（Certification Authority），由它来证明你所连接的服务端就是你想要连接的server，即保证服务端真实性。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h2 id=&quot;http协议&quot;&gt;&lt;a href=&quot;#http协议&quot; class=&quot;headerlink&quot; title=&quot;http协</summary>
      
    
    
    
    <category term="http" scheme="https://hustchenshu.github.io/categories/http/"/>
    
    
    <category term="http" scheme="https://hustchenshu.github.io/tags/http/"/>
    
    <category term="浏览器" scheme="https://hustchenshu.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的执行</title>
    <link href="https://hustchenshu.github.io/2021/04/17/%E8%AF%8D%E6%B3%95-%E8%AF%AD%E6%B3%95/"/>
    <id>https://hustchenshu.github.io/2021/04/17/%E8%AF%8D%E6%B3%95-%E8%AF%AD%E6%B3%95/</id>
    <published>2021-04-17T21:01:02.000Z</published>
    <updated>2022-08-24T02:19:18.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><a href="#javascript%E7%9A%84%E6%89%A7%E8%A1%8C">Javascript的执行</a><ul><li><a href="#%E5%AE%8F%E8%A7%82%E4%BB%BB%E5%8A%A1%E5%BE%AE%E8%A7%82%E4%BB%BB%E5%8A%A1">宏观任务、微观任务</a></li><li><a href="#%E9%97%AD%E5%8C%85%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">闭包与执行上下文</a></li></ul></li><li><a href="#%E8%AF%AD%E5%8F%A5">语句</a><ul><li><a href="#completion-record">Completion Record</a><ul><li><a href="#%E6%99%AE%E9%80%9A%E8%AF%AD%E5%8F%A5">普通语句</a></li><li><a href="#%E8%AF%AD%E5%8F%A5%E5%9D%97">语句块</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">控制语句</a></li><li><a href="#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AF%AD%E5%8F%A5">带标签的语句</a></li></ul></li><li><a href="#%E5%85%A8%E5%B1%80%E6%9C%BA%E5%88%B6">全局机制</a><ul><li><a href="#%E9%A2%84%E5%A4%84%E7%90%86">预处理</a></li><li><a href="#%E6%8C%87%E4%BB%A4%E5%BA%8F%E8%A8%80">指令序言</a></li></ul></li></ul></li></ul><p>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p><p>JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。</p><p>这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。</p><p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列</p><h3 id="宏观任务、微观任务"><a href="#宏观任务、微观任务" class="headerlink" title="宏观任务、微观任务"></a>宏观任务、微观任务</h3><p>我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p><p>分析异步执行的顺序：</p><ul><li>首先分析有多少个宏任务；</li><li>在每个宏任务中，分析有多少个微任务；</li><li>根据调用次序，确定宏任务中微任务的执行次序；</li><li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li><li>确定整个顺序；</li></ul><p>这里有个详细分析的<a href="./%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.md">例子</a>，可以帮助理解这个执行顺序；</p><h3 id="闭包与执行上下文"><a href="#闭包与执行上下文" class="headerlink" title="闭包与执行上下文"></a>闭包与执行上下文</h3><p><code>执行上下文</code></p><p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p><p><code>闭包</code></p><p>当函数能够记住并访问其所在词法作用域时，便形成了闭包；</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/yuju.jpg" alt="yuju"></p><h3 id="Completion-Record"><a href="#Completion-Record" class="headerlink" title="Completion Record"></a>Completion Record</h3><p>Completion Record 表示一个语句执行完之后的结果，JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下 JavaScript 使用 Completion Record 类型，控制语句执行的过程。它有三个字段：</p><ul><li><code>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</code></li><li><code>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</code></li><li><code>[[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。</code></li></ul><h4 id="普通语句"><a href="#普通语句" class="headerlink" title="普通语句"></a>普通语句</h4><p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的[[type]] 如果不为 normal，会打断语句块后续的语句执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">// normal, empty, empty</span></span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// return, 1, empty</span></span><br><span class="line">  i ++; </span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// return, 1, empty</span></span><br></pre></td></tr></table></figure><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p><img src="https://booker-17dbbd-1252444055.tcloudbaseapp.com/cdn/fe-cdn/control.png" alt="control"></p><h4 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h4><p>唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">outer</span>: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="attr">inner</span>: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>)****</span><br></pre></td></tr></table></figure><h3 id="全局机制"><a href="#全局机制" class="headerlink" title="全局机制"></a>全局机制</h3><p>JavaScript 语法的全局机制：预处理和指令序言。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p><pre><code>变量的生命周期：1. 声明阶段：在作用域中注册一个变量；2. 初始化阶段：分配内存，并在作用域中让内存与变量建立了绑定，变量初始化为undefined3. 赋值阶段：代码执行，为初始变量分配一个具体值；</code></pre><ul><li><strong>var声明</strong></li></ul><p>var 声明永远作用于脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。</p><p><strong>声明、初始化阶段耦合，且提升至作用域顶部</strong></p><ul><li><strong>函数声明</strong></li></ul><p>在全局（脚本、模块和函数体），function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值。即：</p><p><strong>声明、初始化、赋值阶段耦合，且提升至作用域顶部</strong></p><p>function 声明出现在 if 等语句中的情况有点复杂，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值：</p><p><strong>声明、初始化阶段耦合，且提升至作用域顶部，但赋值阶段无法穿透控制语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>class</strong></li></ul><p>在 class 声明之前使用 class 名，会抛错；<br><strong>声明阶段提升至作用域顶部，let、const也是如此</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> test =<span class="number">7</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// Error： : Cannot access &#x27;test&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> test =<span class="number">7</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// Error： : Cannot access &#x27;test&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">const</span> test =<span class="number">7</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// Error： : Cannot access &#x27;test&#x27; before initialization</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;&#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span> </span>&#123;&#125;; <span class="comment">// f test()&#123;&#125;</span></span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h4 id="指令序言"><a href="#指令序言" class="headerlink" title="指令序言"></a>指令序言</h4><p>指令序言最早是为了 use strict 设计的，它规定了一种给 JavaScript 代码添加元信息的方式。</p><p>JavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#javascript%E7%9A%84%E6%89%A7%E8%A1%8C&quot;&gt;Javascript的执行&lt;/a&gt;&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://hustchenshu.github.io/tags/javascript/"/>
    
    <category term="词法语法" scheme="https://hustchenshu.github.io/tags/%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
